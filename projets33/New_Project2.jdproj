<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<NDepend AppName="New Project2" Platform="DotNet" FileWrittenByProductVersion="2018.1.0.87">
  <OutputDir KeepXmlFiles="False">C:\Users\yousra\Documents\projets33\JArchitectOut</OutputDir>
  <Projects>
    <Name>C:\Users\yousra\Documents\projets33\nbproject\project.properties</Name>
    <Name>C:\Users\yousra\Documents\projets33\nbproject\project.properties</Name>
    <Name>.\nbproject\project.properties</Name>
  </Projects>
  <FrameworkProjects />
  <Dirs>
    <Dir>C:\Program Files\Java\jre1.8.0_152\lib</Dir>
    <Dir>C:\Users\yousra\Documents\projets33\nbproject</Dir>
  </Dirs>
  <MergeCodeGeneratedByCompiler>True</MergeCodeGeneratedByCompiler>
  <Report Kind="0" SectionsEnabled="110591" XslPath="" Flags="261120" />
  <BuildComparisonSetting ProjectMode="CurrentProject" BuildMode="NDaysAgoAnalysisResult" ProjectFileToCompareWith="" BuildFileToCompareWith="" NDaysAgo="30" />
  <BaselineInUISetting ProjectMode="CurrentProject" BuildMode="NDaysAgoAnalysisResult" ProjectFileToCompareWith="" BuildFileToCompareWith="" NDaysAgo="30" />
  <CoverageFiles CoverageDir="" UncoverableAttribute="" />
  <Plugins PMD="false" CHECKSTYLE="false" FINDBUGS="false" />
  <TrendMetrics UseCustomLog="False" LogRecurrence="3" LogLabel="2" UseCustomDir="False" CustomDir="">
    <Chart Name="Lines of Code" ShowInReport="True">
      <Serie MetricName="# Lines of Code" MetricUnit="Loc" Color="#FF00BFFF" ChartType="Line" ScaleExp="0" />
      <Serie MetricName="# Lines of Code Covered" MetricUnit="Loc" Color="#FF32CD32" ChartType="Area" ScaleExp="0" />
      <Serie MetricName="# Lines of Code (NotMyCode)" MetricUnit="Loc" Color="#FFA9A9A9" ChartType="Area" ScaleExp="0" />
      <Serie MetricName="# Lines of Comments" MetricUnit="Lines" Color="#FF008000" ChartType="Line" ScaleExp="0" />
    </Chart>
    <Chart Name="Rules Violated" ShowInReport="True">
      <Serie MetricName="# Rules" MetricUnit="Rules" Color="#FF66CDAA" ChartType="Line" ScaleExp="0" />
      <Serie MetricName="# Rules Violated" MetricUnit="Rules" Color="#FFFF8C00" ChartType="Area" ScaleExp="0" />
      <Serie MetricName="# Critical Rules Violated" MetricUnit="Rules" Color="#FFFF0000" ChartType="Area" ScaleExp="0" />
    </Chart>
    <Chart Name="Rules Violations" ShowInReport="True">
      <Serie MetricName="# Rules Violations" MetricUnit="Violations" Color="#FFFF8C00" ChartType="Area" ScaleExp="0" />
      <Serie MetricName="# Critical Rules Violations" MetricUnit="Violations" Color="#FFFF0000" ChartType="Area" ScaleExp="0" />
    </Chart>
    <Chart Name="Percentage Coverage by Tests" ShowInReport="True">
      <Serie MetricName="Percentage Code Coverage" MetricUnit="%" Color="#FF32CD32" ChartType="Area" ScaleExp="0" />
    </Chart>
    <Chart Name="Max" ShowInReport="True">
      <Serie MetricName="Max BC Cyclomatic Complexity for Methods" MetricUnit="Paths" Color="#FFFF0000" ChartType="Line" ScaleExp="0" />
      <Serie MetricName="Max # Lines of Code for Methods (JustMyCode)" MetricUnit="LoC" Color="#FF0000FF" ChartType="Line" ScaleExp="0" />
      <Serie MetricName="Max # of Methods for Types" MetricUnit="Methods" Color="#FF32CD32" ChartType="Line" ScaleExp="0" />
      <Serie MetricName="Max BC Nesting Depth for Methods" MetricUnit="Scopes" Color="#FFFFD700" ChartType="Line" ScaleExp="0" />
    </Chart>
    <Chart Name="Average" ShowInReport="True">
      <Serie MetricName="Average BC Cyclomatic Complexity for Methods" MetricUnit="Paths" Color="#FFFF0000" ChartType="Line" ScaleExp="0" />
      <Serie MetricName="Average # Lines of Code for Methods" MetricUnit="LoC" Color="#FF0000FF" ChartType="Line" ScaleExp="0" />
      <Serie MetricName="Average # Methods for Types" MetricUnit="Methods" Color="#FF32CD32" ChartType="Line" ScaleExp="0" />
      <Serie MetricName="Average BC Nesting Depth for Methods" MetricUnit="Scopes" Color="#FFFFD700" ChartType="Line" ScaleExp="0" />
    </Chart>
    <Chart Name="Third-Party Usage" ShowInReport="True">
      <Serie MetricName="# Third-Party Types Used" MetricUnit="Types" Color="#FF0000FF" ChartType="Line" ScaleExp="0" />
      <Serie MetricName="# Third-Party Methods Used" MetricUnit="Methods" Color="#FFFF0000" ChartType="Line" ScaleExp="0" />
      <Serie MetricName="# Third-Party Projects Used" MetricUnit="Projects" Color="#FF646464" ChartType="Line" ScaleExp="1" />
      <Serie MetricName="# Third-Party Packages Used" MetricUnit="PACKAGES" Color="#FF32CD32" ChartType="Line" ScaleExp="1" />
      <Serie MetricName="# Third-Party Fields Used" MetricUnit="Fields" Color="#FFFFD700" ChartType="Line" ScaleExp="1" />
    </Chart>
  </TrendMetrics>
  <HistoricAnalysisResult PersistRecurrence="3" UseCustomDir="False" CustomDir="" />
  <SourceFileRebasing FromPath="" ToPath="" />
  <PathVariables />
  <RuleFiles />
  <ProjectRules AreActive="True" />
  <ProjectDebtSettings DebtSettingsStorage="0" SettingsFilePath="">
    <DebtSettings>
      <DebtFactor>1</DebtFactor>
      <AnnualInterestFactor>1</AnnualInterestFactor>
      <DebtDefault>0</DebtDefault>
      <AnnualInterestDefault>0</AnnualInterestDefault>
      <DebtStringFormat>$ManDay$</DebtStringFormat>
      <MoneyPerManHour>50</MoneyPerManHour>
      <Currency>USD</Currency>
      <CurrencyLocation>After</CurrencyLocation>
      <EstimatedNumberOfManDayToDevelop1000LogicalLinesOfCode>18</EstimatedNumberOfManDayToDevelop1000LogicalLinesOfCode>
      <NumberOfWorkDayPerYear>240</NumberOfWorkDayPerYear>
      <NumberOfWorkHourPerDay>8</NumberOfWorkHourPerDay>
      <A2B_RatingThreshold>5</A2B_RatingThreshold>
      <B2C_RatingThreshold>10</B2C_RatingThreshold>
      <C2D_RatingThreshold>20</C2D_RatingThreshold>
      <D2E_RatingThreshold>50</D2E_RatingThreshold>
      <Info2Minor_SeverityThreshold>1200000000</Info2Minor_SeverityThreshold>
      <Minor2Major_SeverityThreshold>12000000000</Minor2Major_SeverityThreshold>
      <Major2Critical_SeverityThreshold>72000000000</Major2Critical_SeverityThreshold>
      <Critical2Blocker_SeverityThreshold>360000000000</Critical2Blocker_SeverityThreshold>
    </DebtSettings>
  </ProjectDebtSettings><Queries>
    <Group Name="Quality Gates" Active="True" ShownInReport="True">
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Quality Gates Evolution</Name>
from qg in QualityGates
let qgBaseline = qg.OlderVersion()
let relyOnDiff = qgBaseline == null
let evolution = relyOnDiff ? (TrendIcon?)null : 
                // When a quality gate relies on diff between now and baseline
                // it is not executed against the baseline
                qg.ValueDiff() == 0d ?
                TrendIcon.Constant :
                (qg.ValueDiff() > 0 ? 
                  ( qg.MoreIsBad ?  TrendIcon.RedUp: TrendIcon.GreenUp) :
                  (!qg.MoreIsBad ?  TrendIcon.RedDown: TrendIcon.GreenDown))
select new { qg, 
   Evolution      =  evolution,

   BaselineStatus =  relyOnDiff? (QualityGateStatus?) null : qgBaseline.Status,
   Status         =  qg.Status,

   BaselineValue  =  relyOnDiff? (null) : qgBaseline.ValueString,
   Value          =  qg.ValueString, 
}
 
// <Description>
// Show quality gates evolution between baseline and now.
//
// When a quality gate relies on diff between now and baseline (like *New Debt since Baseline*)
// it is not executed against the baseline and as a consequence its evolution is not available.
//
// Double-click a quality gate for editing.
// </Description>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <QualityGate Name="Percentage Code Coverage" Unit="%" />
failif value < 70%
warnif value < 80%
codeBase.PercentageCoverage

//<Description>
// Code coverage is a measure used to describe the degree to which the source code of a program 
// is tested by a particular test suite. A program with high code coverage, measured as a percentage, 
// has had more of its source code executed during testing which suggests it has a lower chance of 
// containing undetected software bugs compared to a program with low code coverage.
//
// Code coverage is certainly the most important quality code metric. But coverage is not enough
// the team needs to ensure that results are checked at test-time. These checks can be done both 
// in test code, and in application code through assertions. The important part is that a test
// must fail explicitely when a check gets unvalidated during the test execution.
//
// This quality gate define a warn threshold (70%) and a fail threshold (80%). These are 
// indicative thresholds and in practice the more the better. To achieve high coverage and 
// low risk, make sure that new and refactored classes gets 100% covered by tests and that
// the application and test code contains as many checks/assertions as possible.
//</Description>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <QualityGate Name="Percentage Coverage on New Code" Unit="%" />
failif value < 70%
warnif value < 80%
let newMethods = Application.Methods.Where(m => m.WasAdded() && m.NbLinesOfCode > 0)
let locCovered = newMethods.Sum(m => m.NbLinesOfCodeCovered)
let loc = newMethods.Sum(m => m.NbLinesOfCode)
select 100d * locCovered / loc

//<Description>
// *New Code* is defined as methods added since the baseline.
//
// To achieve high code coverage it is essential that new code gets properly
// tested and covered by tests. It is advised that all non-UI new classes gets
// 100% covered.
//
// Typically 90% of a class is easy to cover by tests and 10% is hard to reach 
// through tests. It means that this 10% remaining is not easily testable, which 
// means it is not well designed, which often means that this code is especially 
// **error-prone**. This is the reason why it is important to reach 100% coverage
// for a class, to make sure that potentially *error-prone* code gets tested.
//</Description>
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <QualityGate Name="Percentage Coverage on Refactored Code" Unit="%" />
failif value < 70%
warnif value < 80%
let newMethods = Application.Methods.Where(m => m.CodeWasChanged() && m.NbLinesOfCode > 0)
let locCovered = newMethods.Sum(m => m.NbLinesOfCodeCovered)
let loc = newMethods.Sum(m => m.NbLinesOfCode)
select 100d * locCovered / loc

//<Description>
// *Refactored Code* is defined as methods where *code was changed* since the baseline.
//
// Comment changes and formatting changes are not considerd as refactoring.
//
// To achieve high code coverage it is essential that refactored code gets properly
// tested and covered by tests. It is advised that when refactoring a class
// or a method, it is important to also write tests to make sure it gets 100% covered.
//
// Typically 90% of a class is easy to cover by tests and 10% is hard to reach 
// through tests. It means that this 10% remaining is not easily testable, which 
// means it is not well designed, which often means that this code is especially 
// **error-prone**. This is the reason why it is important to reach 100% coverage
// for a class, to make sure that potentially *error-prone* code gets tested.
//</Description>
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <QualityGate Name="Blocker Issues" Unit="issues" />
failif count > 0 issues
from i in Issues
where i.Severity == Severity.Blocker
select new { i, i.Severity, i.Debt, i.AnnualInterest }

//<Description>
// An issue with the severity **Blocker** cannot move to production, it must be fixed.
//
// The severity of an issue is either defined explicitely in the rule source code,
// either inferred from the issue *annual interest* and thresholds defined in the 
// NDepend Project Properties > Issue and Debt.
//</Description>

]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <QualityGate Name="Critical Issues" Unit="issues" />
failif count > 10 issues
warnif count > 0 issues

from i in Issues
where i.Severity == Severity.Critical
select new { i, i.Severity, i.Debt, i.AnnualInterest }

//<Description>
// An issue with a severity level **Critical** shouldn't move to production. 
// It still can for business imperative needs purposes, but at worst it must 
// be fixed during the next iterations. 
//
// The severity of an issue is either defined explicitely in the rule source code,
// either inferred from the issue *annual interest* and thresholds defined in the 
// NDepend Project Properties > Issue and Debt.
//</Description>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <QualityGate Name="New Blocker / Critical / Major Issues" Unit="issues" />
failif count > 0 issues
from i in Issues
where i.Severity.EqualsAny(Severity.Blocker, Severity.Critical, Severity.High) &&  
      // Count both the new issues and the issues that became at least Critical
      (i.WasAdded() || i.OlderVersion().Severity < Severity.High)
select new { i, i.Severity, i.Debt, i.AnnualInterest }


//<Description>
// An issue with the severity **Blocker** cannot move to production, it must be fixed.
//
// An issue with a severity level **Critical** shouldn't move to production. 
// It still can for business imperative needs purposes, but at worth it must be fixed 
// during the next iterations. 
//
// An issue with a severity level **Major** should be fixed quickly, but can wait until 
// the next scheduled interval.
//
// The severity of an issue is either defined explicitely in the rule source code,
// either inferred from the issue *annual interest* and thresholds defined in the 
// NDepend Project Properties > Issue and Debt.
//</Description>
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <QualityGate Name="Critical Rules Violated" Unit="rules" />
failif count > 0 rules
from r in Rules where r.IsCritical && r.IsViolated()
select new { r, issues = r.Issues() }

//<Description>
// The concept of critical rule is useful to pinpoint certain rules that 
// should not be violated.
//
// A rule can be made critical just by checking the *Critical button* in the
// rule edition control and then saving the rule.
//
// This quality gate fails if any critical rule gets any violations.
//
// When no baseline is available, rules that rely on diff are not counted.
// If you observe that this quality gate count slightly decreases with no apparent reason,
// the reason is certainly that rules that rely on diff are not counted
// because the baseline is not defined.
//</Description>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <QualityGate Name="Percentage Debt" Unit="%" />
failif value > 30%
warnif value > 20%
let timeToDev = codeBase.EffortToDevelop()
let debt = Issues.Sum(i => i.Debt)
select 100d * debt.ToManDay() / timeToDev.ToManDay()

// <Description>
// % Debt total is defined as a percentage on:
//
// • the estimated total effort to develop the code base
//
// • and the the estimated total time to fix all issues (the Debt)
//
// Estimated total effort to develop the code base is inferred from 
// # lines of code of the code base and from the 
// *Estimated number of man-dat to develop 1000 logicial lines of code*
// setting found in NDepend Project Properties > Issue and Debt.
//
// Debt documentation: http://www.jarchitect.com/Doc_TechnicalDebtt#Debt
//
// This quality gates fails if the estimated debt is more than 30%
// of the estimated effort to develop the code base, and warns if the 
// estimated debt is more than 20% of the estimated effort to develop 
// the code base
// </Description>]]></Query>
      <Query Active="False" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <QualityGate Name="Debt" Unit="man-days" />
failif value > 50 man-days
warnif value > 30 man-days
Issues.Sum(i => i.Debt).ToManDay()

//<Description>
// This Quality Gate is disabled per default because the fail and warn 
// thresholds of unacceptable Debt in man-days can only depend on the 
// project size, number of developers and overall context.
//
// However you can refer to the default Quality Gate **Percentage Debt**.
//
// The Debt is defined as the sum of estimated effort to fix all issues.
// Debt documentation: http://www.jarchitect.com/Doc_TechnicalDebtt#Debt
//</Description>

]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <QualityGate Name="New Debt since Baseline" Unit="man-days" />
failif value > 2 man-days
warnif value > 0 man-days
let debt = Issues.Sum(i => i.Debt)
let debtInBaseline = IssuesInBaseline.Sum(i => i.Debt)
select (debt - debtInBaseline).ToManDay()


//<Description>
// This Quality Gate fails if the estimated effort to fix new or worsened
// issues (what is called the *New Debt since Baseline*) is higher
// than 2 man-days.
//
// This Quality Gate warns if this estimated effort is positive.
//
// Debt documentation: http://www.jarchitect.com/Doc_TechnicalDebtt#Debt
//</Description>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <QualityGate Name="Debt Rating per Package" Unit="packages" />
failif count > 0 packages

from n in Application.Packages
where n.DebtRating() != null &&
      n.DebtRating().Value.EqualsAny(DebtRating.E, DebtRating.D)
select new { 
   n, 
   debtRating = n.DebtRating(),
   debtRatio = n.DebtRatio(),  // % of debt from which DebtRating is inferred
   devTimeInManDay = n.EffortToDevelop().ToDebt(), 
   debtInManDay = n.AllDebt(),
   issues = n.AllIssues() 
}

// <Description>
// Forbid packages with a poor Debt Rating equals to **E** or **D**.
//
// The **Debt Rating** for a code element is estimated by the value of the **Debt Ratio**
// and from the various rating thresholds defined in this project *Debt Settings*. 
//
// The **Debt Ratio** of a code element is a percentage of **Debt Amount** (in floating man-days) 
// compared to the **estimated effort to develop the code element** (also in floating man-days).
//
// The **estimated effort to develop the code element** is inferred from the code elements
// number of lines of code, and from the project *Debt Settings* parameters 
// *estimated number of man-days to develop 1000* **logical lines of code**.
//
// The **logical lines of code** corresponds to the number of debug breakpoints in a method
// and doesn't depend on code formatting nor comments.
//
// The Quality Gate can be modified to match Projects, types or methods
// with a poor Debt Rating, instead of matching packages.
// </Description>]]></Query>
      <Query Active="False" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <QualityGate Name="Annual Interest" Unit="man-days" />
failif value > 50 man-days
warnif value > 30 man-days
Issues.Sum(i => i.AnnualInterest).ToManDay()


//<Description>
// This Quality Gate is disabled per default because the fail and warn 
// thresholds of unacceptable Annual-Interest in man-days can only depend
// on the project size, number of developers and overall context.
//
// However you can refer to the default Quality Gate 
// **New Annual Interest since Baseline**.
//
// The Annual-Interest is defined as the sum of estimated annual cost
// in man-days, to leave all issues unfixed.
//
// Each rule can either provide a formula to compute the Annual-Interest 
// per issue, or assign a **Severity** level for each issue. Some thresholds
// defined in *Project Properties > Issue and Debt > Annual Interest* are
// used to infer an Annual-Interest value from a Severity level.
// Annual Interest documentation: http://www.jarchitect.com/Doc_TechnicalDebtt#AnnualInterest
//</Description>


]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <QualityGate Name="New Annual Interest since Baseline" Unit="man-days" />
failif value > 2 man-days
warnif value > 0 man-days
let ai = Issues.Sum(i => i.AnnualInterest)
let aiInBaseline = IssuesInBaseline.Sum(i => i.AnnualInterest)
select (ai - aiInBaseline).ToManDay()

//<Description>
// This Quality Gate fails if the estimated annual cost to leave all issues
// unfixed, increased from more than 2 man-days since the baseline.
//
// This Quality Gate warns if this estimated annual cost is positive.
//
// This estimated annual cost is named the **Annual-Interest**.
//
// Each rule can either provide a formula to compute the Annual-Interest 
// per issue, or assign a **Severity** level for each issue. Some thresholds
// defined in *Project Properties > Issue and Debt > Annual Interest* are
// used to infer an Annual-Interest value from a Severity level.
// Annual Interest documentation: http://www.jarchitect.com/Doc_TechnicalDebtt#AnnualInterest
//</Description>

]]></Query>
    </Group>
    <Group Name="Code Smell" Active="True" ShownInReport="False">
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="True"><![CDATA[// <Name>Avoid types too big</Name>
warnif count > 0 from t in JustMyCode.Types where 

   // First filter on type to optimize 
   t.NbLinesOfCode > 200 
  
   // What matters is the # lines of code in JustMyCode
   let locJustMyCode = t.MethodsAndContructors.Where(m => JustMyCode.Contains(m)).Sum(m => m.NbLinesOfCode)
   where locJustMyCode > 200

   let isStaticWithNoMutableState = (t.IsStatic && t.Fields.Any(f => !f.IsImmutable))
   let staticFactor = (isStaticWithNoMutableState ? 0.2 : 1)

   orderby locJustMyCode descending
select new { 
   t, 
   locJustMyCode, 
   t.NbBCInstructions,
   t.Methods, 
   t.Fields,
   
   Debt = (staticFactor*locJustMyCode.Linear(200, 1, 2000, 10)).ToHours().ToDebt(),

   // The annual interest varies linearly from interest for severity major for 300 loc
   // to interest for severity critical for 2000 loc
   AnnualInterest = staticFactor*(locJustMyCode.Linear(
                          200,  Severity.Medium.AnnualInterestThreshold().Value.TotalMinutes, 
                          2000, Severity.Critical.AnnualInterestThreshold().Value.TotalMinutes)).ToMinutes().ToAnnualInterest()
}

//<Description>
// This rule matches types with more than 200 lines of code.
// **Only lines of code in JustMyCode methods are taken account.**
//
// Types where *NbLinesOfCode > 200* are extremely complex 
// to develop and maintain.
// See the definition of the NbLinesOfCode metric here 
// http://www.jarchitect.com/docs/code-metrics#NbLinesOfCode
//
//</Description>

//<HowToFix>
// Types with many lines of code
// should be split in a group of smaller types.
// 
// To refactor a big Class you'll need patience, 
// and you might even need to recreate everything from scratch.
// Here are a few refactoring advices:
//
// • The logic in the Big Class must be splitted in smaller classes.
// These smaller classes can eventually become private classes nested
// in the original *Big Class*, whose instances objects become 
// composed of instances of smaller nested classes.
//
// • Smaller classes partitioning should be driven by the multiple
// responsibilities handled by the *Big Class*. To identify these 
// responsibilities it often helps to look for subsets of methods
// strongly coupled with subsets of fields.
//
// • If the *Big Class* contains way more logic than states, a good 
// option can be to define one or several static classes that 
// contains no static field but only pure static methods. A pure static 
// method is a function that computes a result only from inputs
// parameters, it doesn't read nor assign any static or instance field.
// The main advantage of pure static methods is that they are easily
// testable.
// 
// • Try to maintain the interface of the Big Class at first 
// and delegate calls to the new extracted classes. 
// In the end the Big Class should be a pure facade without its own logic.
// Then you can keep it for convenience or throw it away and 
// start to use the new classes only.
//
// • Unit Tests can help: write tests for each method before extracting it 
// to ensure you don't break functionality.
//
// The estimated Debt, which means the effort to fix such issue,
// varies linearly from 1 hour for a 200 lines of code type,
// up to 10 hours for a type with 2.000 or more lines of code.
//
// In Debt and Interest computation, this rule takes account of the fact 
// that static types with no mutable fields are just a collection of 
// static methods that can be easily splitted and moved from one type 
// to another.
//</HowToFix>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Avoid types with too many methods</Name>
warnif count > 0 from t in JustMyCode.Types 

  // Optimization: Fast discard of non-relevant types 
  where t.Methods.Count() > 20

  // Don't match these methods
  let methods = t.Methods.Where(
       m => !(m.IsGeneratedByCompiler ||
              m.IsConstructor || m.IsClassConstructor ||
              m.IsPropertyGetter || m.IsPropertySetter))

  where methods.Count() > 20 
  orderby methods.Count() descending

  let isStaticWithNoMutableState = (t.IsStatic && t.Fields.Any(f => !f.IsImmutable))
  let staticFactor = (isStaticWithNoMutableState ? 0.2 : 1)

select new { 
   t, 
   nbMethods = methods.Count(),
   instanceMethods = methods.Where(m => !m.IsStatic), 
   staticMethods = methods.Where(m => m.IsStatic),

   t.NbLinesOfCode,

   Debt = (staticFactor*methods.Count().Linear(20, 1, 200, 10)).ToHours().ToDebt(),

   // The annual interest varies linearly from interest for severity major for 30 methods
   // to interest for severity critical for 200 methods
   AnnualInterest = (staticFactor*methods.Count().Linear(
                              20,  Severity.Medium.AnnualInterestThreshold().Value.TotalMinutes, 
                              200, Severity.Critical.AnnualInterestThreshold().Value.TotalMinutes)).ToMinutes().ToAnnualInterest()
}

//<Description>
// This rule matches types with more than 20 methods. 
// Such type might be hard to understand and maintain.
//
// Notice that methods like constructors or property 
// and event accessors are not taken account.
//
// Having many methods for a type might be a symptom
// of too many responsibilities implemented.
//
// Maybe you are facing the **Big Class** phenomenon:
// A **Big Class** is a class that controls way too many other classes 
// in the system and has grown beyond all logic to become 
// *The Class That Does Everything*.
//</Description>

//<HowToFix>
// To refactor properly a *Big Class* please read *HowToFix advices* 
// from the default rule **Types to Big**.
////
// The estimated Debt, which means the effort to fix such issue,
// varies linearly from 1 hour for a type with 20 methods,
// up to 10 hours for a type with 200 or more methods.
//
// In Debt and Interest computation, this rule takes account of the fact 
// that static types with no mutable fields are just a collection of 
// static methods that can be easily splitted and moved from one type 
// to another.
//</HowToFix>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Avoid types with too many fields</Name>
warnif count > 0 from t in JustMyCode.Types 

  // Optimization: Fast discard of non-relevant types 
  where !t.IsEnumeration &&
         t.Fields.Count() > 15
        
  // Count instance fields and non-constant static fields
  let fields = t.Fields.Where(f =>
          !f.IsGeneratedByCompiler &&
          !f.IsLiteral &&
          !(f.IsStatic && f.IsInitOnly) &&
           JustMyCode.Contains(f) )

  where fields.Count() > 15
 
  let methodsAssigningFields = fields.SelectMany(f => f.MethodsAssigningMe)

  orderby fields.Count() descending
select new { 
   t, 
   instanceFields = fields.Where(f => !f.IsStatic),
   staticFields = fields.Where(f => f.IsStatic),
methodsAssigningFields ,   

   // See definition of Size of Instances metric here:
   // http://www.jarchitect.com/docs/code-metrics#SizeOfInst
   t.SizeOfInst,

   Debt = fields.Count().Linear(15, 1, 200, 10).ToHours().ToDebt(),

   // The annual interest varies linearly from interest for severity major for 30 methods
   // to interest for severity critical for 200 methods
   AnnualInterest = fields.Count().Linear(15,  Severity.Medium.AnnualInterestThreshold().Value.TotalMinutes, 
                                          200, Severity.Critical.AnnualInterestThreshold().Value.TotalMinutes).ToMinutes().ToAnnualInterest()
}

//<Description>
// This rule matches types with more than 15 fields. 
// Such type might be hard to understand and maintain.
//
// Notice that constant fields and static-readonly fields are not counted.
// Enumerations types are not counted also.
//
// Having many fields for a type might be a symptom
// of too many responsibilities implemented.
//</Description>

//<HowToFix>
// To refactor such type and increase code quality and maintainability,
// certainly you'll have to group subsets of fields into smaller types
// and dispatch the logic implemented into the methods 
// into these smaller types.
//
// More refactoring advices can be found in the default rule 
// **Types to Big**, *HowToFix* section.
//
// The estimated Debt, which means the effort to fix such issue,
// varies linearly from 1 hour for a type with 15 fields,
// to up to 10 hours for a type with 200 or more fields. 
//</HowToFix>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="True"><![CDATA[// <Name>Avoid methods too big, too complex</Name>
warnif count > 0 from m in JustMyCode.Methods where 
   (m.NbLinesOfCode > 35 ||
   m.CyclomaticComplexity > 20 ||
   m.BCCyclomaticComplexity > 60) && m.BCNestingDepth > 2 

  let complexityScore = m.NbLinesOfCode/2 + m.CyclomaticComplexity + m.BCCyclomaticComplexity/3 + 3*m.BCNestingDepth

  orderby complexityScore descending,
          m.CyclomaticComplexity descending,
          m.BCCyclomaticComplexity descending,
          m.BCNestingDepth descending
select new { 
   m, 
   m.NbLinesOfCode,
   m.CyclomaticComplexity, 
   m.BCCyclomaticComplexity,
   m.BCNestingDepth,
   complexityScore,

   Debt = complexityScore.Linear(30, 40,    400, 8*60).ToMinutes().ToDebt(),

   // The annual interest varies linearly from interest for severity minor 
   // to interest for severity major
   AnnualInterest = complexityScore .Linear(30,     Severity.Medium.AnnualInterestThreshold().Value.TotalMinutes, 
                                            200, 2*(Severity.High.AnnualInterestThreshold().Value.TotalMinutes)).ToMinutes().ToAnnualInterest()
   
}

//<Description>
// This rule matches methods where *BCNestingDepth* > 2
// and (*NbLinesOfCode* > 35 
// or *CyclomaticComplexity* > 20
// or *BCCyclomaticComplexity* > 60)
// Such method is typically hard to understand and maintain.
//
// Maybe you are facing the **Big Method** phenomenon.
// A "Big Method" is a method that does way too many processes in the system 
// and has grown beyond all logic to become *The Method That Does Everything*.
// When need for new processes increases suddenly some programmers realize: 
// why should I create a new method for each processe if I can only add an *if*.
//
// See the definition of the *CyclomaticComplexity* metric here:
// http://www.jarchitect.com/docs/code-metrics#CC
//
// See the definition of the *BCCyclomaticComplexity* metric here:
// http://www.jarchitect.com/docs/code-metrics#ILCC
//
// See the definition of the *BCNestingDepth* metric here:
// http://www.jarchitect.com/docs/code-metrics#BCNestingDepth
//</Description>

//<HowToFix>
// A large and complex method should be split in smaller methods, 
// or even one or several classes can be created for that.
//
// During this process it is important to question the scope of each
// variable local to the method. This can be an indication if
// such local variable will become an instance field of the newly created class(es).
//
// Large *switch…case* structures might be refactored through the help
// of a set of types that implement a common interface, the interface polymorphism
// playing the role of the *switch cases tests*.
//
// Unit Tests can help: write tests for each method before extracting it 
// to ensure you don't break functionality.
//
// The estimated Debt, which means the effort to fix such issue,
// varies from 40 minutes to 8 hours, linearly from a weighted complexity score.
//</HowToFix>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="True"><![CDATA[// <Name>Avoid methods with too many parameters</Name>
warnif count > 0 from m in JustMyCode.Methods where 
  m.NbParameters >= 7
  orderby m.NbParameters descending
select new { 
   m, 
   m.NbParameters,

   Debt = m.NbParameters.Linear(7, 1,  40, 6).ToHours().ToDebt(),

   // The annual interest varies linearly from interest for severity Minor for 7 parameters
   // to interest for severity Critical for 40 parameters
   AnnualInterest = m.NbParameters.Linear(7,  Severity.Medium.AnnualInterestThreshold().Value.TotalMinutes, 
                                          40, Severity.Critical.AnnualInterestThreshold().Value.TotalMinutes).ToMinutes().ToAnnualInterest()
}

//<Description>
// This rule matches methods with more than 8 parameters.
// Such method is painful to call and might degrade performance.
// See the definition of the *NbParameters* metric here: 
// http://www.jarchitect.com/docs/code-metrics#NbParameters
//</Description>

//<HowToFix>
// More properties/fields can be added to the declaring type to 
// handle numerous states. An alternative is to provide 
// a class or a structure dedicated to handle arguments passing.
// For example see the class *System.Diagnostics.ProcessStartInfo* 
// and the method *System.Diagnostics.Process.Start(ProcessStartInfo)*.
//
// The estimated Debt, which means the effort to fix such issue,
// varies linearly from 1 hour for a method with 7 parameters,
// up to 6 hours for a methods with 40 or more parameters.
//</HowToFix>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Avoid methods with too many local variables</Name>
warnif count > 0 from m in JustMyCode.Methods where 
  m.NbVariables > 15 
  orderby m.NbVariables descending
select new { 
   m, 
   m.NbVariables,

   Debt = m.NbVariables.Linear(15, 1,   80, 6).ToHours().ToDebt(),

   // The annual interest varies linearly from interest for severity Minor for 15 variables
   // to interest for severity Critical for 80 variables
   AnnualInterest = m.NbVariables.Linear(15,  Severity.Medium.AnnualInterestThreshold().Value.TotalMinutes, 
                                         80,  Severity.Critical.AnnualInterestThreshold().Value.TotalMinutes).ToMinutes().ToAnnualInterest()

}

//<Description>
// This rule matches methods with more than 15 variables.
//
// Methods where *NbVariables > 8* are hard to understand and maintain.
// Methods where *NbVariables > 15* are extremely complex and must be refactored. 
//
// See the definition of the *Nbvariables* metric here: 
// http://www.jarchitect.com/docs/code-metrics#Nbvariables
//</Description>

//<HowToFix>
// To refactor such method and increase code quality and maintainability,
// certainly you'll have to split the method into several smaller methods
// or even create one or several classes to implement the logic.
//
// During this process it is important to question the scope of each
// variable local to the method. This can be an indication if
// such local variable will become an instance field of the newly created class(es).
//
// The estimated Debt, which means the effort to fix such issue,
// varies linearly from 10 minutes for a method with 15 variables,
// up to 2 hours for a methods with 80 or more variables.
//</HowToFix>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Avoid methods with too many overloads</Name>
warnif count > 0 from m in JustMyCode.Methods where 
   m.NbOverloads >= 6 
  orderby m.NbOverloads descending
let overloads = 
 m.IsConstructor ? m.ParentType.Constructors :
                   m.ParentType.Methods.Where(m1 => m1.SimpleName == m.SimpleName)
select new { 
   m, 
   overloads,
   Debt = 2.ToMinutes().ToDebt(),
   Severity = Severity.Medium
}

//<Description>
// Method overloading is the ability to create multiple methods of the same name 
// with different implementations, and various set of parameters.
//
// This rule matches sets of methods with 6 overloads or more.
//
// Such method set might be a problem to maintain 
// and provokes coupling higher than necessary.
//
// See the definition of the *NbOverloads* metric here 
// http://www.jarchitect.com/docs/code-metrics#NbOverloads
//</Description>

//<HowToFix>
// Typically the *too many overloads* phenomenon appears when an algorithm
// takes a various set of in-parameters. Each overload is presented as 
// a facility to provide a various set of in-parameters.
// In such situation, the C# and VBJava language feature named 
// *Named and Optional arguments* should be used.
//
// The *too many overloads* phenomenon can also be a consequence of the usage
// of the **visitor design pattern** http://en.wikipedia.org/wiki/Visitor_pattern 
// since a method named *Visit()* must be provided for each sub type.
// In such situation there is no need for fix.
//
// Sometime *too many overloads* phenomenon is not the symptom of a problem,
// for example when a *numeric to something conversion* method applies to 
// all numeric and nullable numeric types.
//
// The estimated Debt, which means the effort to fix such issue,
// is of 2 minutes per method overload.
//</HowToFix>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Avoid methods potentially poorly commented</Name>
warnif count > 0 from m in JustMyCode.Methods where 
  m.PercentageComment < 20 && 
  m.NbLinesOfCode > 20  

  let nbLinesOfCodeNotCommented = m.NbLinesOfCode - m.NbLinesOfComment

  orderby nbLinesOfCodeNotCommented descending

select new { 
   m, 
   m.PercentageComment, 
   m.NbLinesOfCode, 
   m.NbLinesOfComment,
   nbLinesOfCodeNotCommented,

   Debt = nbLinesOfCodeNotCommented .Linear(20, 2,  200, 20).ToMinutes().ToDebt(),

   // The annual interest varies linearly from interest for severity major for 300 loc
   // to interest for severity critical for 2000 loc
   AnnualInterest = m.PercentageComment.Linear(
                         0,  8 *(Severity.Medium.AnnualInterestThreshold().Value.TotalMinutes), 
                         20,     Severity.Medium.AnnualInterestThreshold().Value.TotalMinutes).ToMinutes().ToAnnualInterest()  
}

//<Description>
// This rule matches methods with less than 20% of comment lines and that have 
// at least 20 lines of code. Such method might need to be more commented.
//
// See the definitions of the *Comments metric* here:
// http://www.jarchitect.com/docs/code-metrics#PercentageComment
// http://www.jarchitect.com/docs/code-metrics#NbLinesOfComment
// 
// Notice that only comments about the method implementation
// (comments in method body) are taken account.
//</Description>

//<HowToFix>
// Typically add more comment. But code commenting is subject to controversy.
// While poorly written and designed code would needs a lot of comment 
// to be understood, clean code doesn't need that much comment, especially
// if variables and methods are properly named and convey enough information.
// Unit-Test code can also play the role of code commenting.
//
// However, even when writing clean and well-tested code, one will have
// to write **hacks** at a point, usually to circumvent some API limitations or bugs.
// A hack is a non-trivial piece of code, that doesn't make sense at first glance,
// and that took time and web research to be found.
// In such situation comments must absolutely be used to express the intention, 
// the need for the hacks and the source where the solution has been found.
//
// The estimated Debt, which means the effort to comment such method,
// varies linearly from 2 minutes for 10 lines of code not commented,
// up to 20 minutes for 200 or more, lines of code not commented.
//</HowToFix>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Avoid types with poor cohesion</Name>
warnif count > 0 from t in JustMyCode.Types where 
  t.LCOM > 0.8  && 
  t.NbFields > 10 && 
  t.NbMethods >10 

  let poorCohesionScore = 1/(1.01 - t.LCOM)
  orderby poorCohesionScore descending

  select new { 
   t, 
   t.LCOM, 
   t.NbMethods, 
   t.NbFields,
   poorCohesionScore,

   Debt = poorCohesionScore.Linear(5, 5, 50, 4*60).ToMinutes().ToDebt(),

   // The annual interest varies linearly from interest for severity Minor for low poorCohesionScore
   // to 4 times interest for severity Major for high poorCohesionScore
   AnnualInterest = poorCohesionScore.Linear(5,     Severity.Medium.AnnualInterestThreshold().Value.TotalMinutes, 
                                             50, 4*(Severity.High.AnnualInterestThreshold().Value.TotalMinutes)).ToMinutes().ToAnnualInterest()
   
}

//<Description>
// This rule is based on the *LCOM code metric*,
// LCOM stands for **Lack Of Cohesion of Methods**.
// See the definition of the LCOM metric here 
// http://www.jarchitect.com/docs/code-metrics#LCOM
//
// The LCOM metric measures the fact that most methods are using most fields.
// A class is considered utterly cohesive (which is good)
// if all its methods use all its instance fields.
//
// Only types with enough methods and fields are taken account to avoid bias.
// The LCOM takes its values in the range [0-1].
//
// This rule matches types with LCOM higher than 0.8.
// Such value generally pinpoints a **poorly cohesive class**.
//</Description>

//<HowToFix>
// To refactor a poorly cohesive type and increase code quality and maintainability,
// certainly you'll have to split the type into several smaller and more cohesive types
// that together, implement the same logic.
//
// The estimated Debt, which means the effort to fix such issue,
// varies linearly from 5 minutes for a type with a low poorCohesionScore,
// up to 4 hours for a type with high poorCohesionScore.
//</HowToFix>]]></Query>
    </Group>
    <Group Name="Code Smells Regression" Active="True" ShownInReport="False">
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>From now, all types added should respect basic quality principles</Name>
warnif count > 0 from t in JustMyCode.Types where

// Only match types added since Baseline.
// Uncomment this line to match also refactored types since Baseline.
// (t.WasAdded() || t.CodeWasChanged()) &&
   t.WasAdded() &&

// Eliminate interfaces, enumerations or types only with constant fields
// by making sure we are matching type with code.
t.NbLinesOfCode > 10 &&

// Optimization: Fast discard of non-relevant types 
(t.Fields.Count() > 20 || t.Methods.Count() > 20)
      
// Count instance fields and non-constant static fields
let fields = t.Fields.Where(f => 
      !f.IsLiteral &&
      !(f.IsStatic && f.IsInitOnly))

// Don't match these methods
let methods = t.Methods.Where(
   m => !(m.IsConstructor || m.IsClassConstructor ||
          m.IsGeneratedByCompiler ||
          m.IsPropertyGetter || m.IsPropertySetter))
  
where 

// Low Quality types     Metrics' definitions are available here:
//     http://www.jarchitect.com/docs/code-metrics#MetricsOnTypes
(  // Types with too many methods
   fields.Count() > 20 ||

   methods.Count() > 20 ||
               
   // Complex Types that use more than 50 other types
   t.NbTypesUsed > 50
)
select new { 
   t, 
   t.NbLinesOfCode, 

   instanceMethods = methods.Where(m => !m.IsStatic), 
   staticMethods = methods.Where(m => m.IsStatic),
  
   instanceFields = fields.Where(f => !f.IsStatic),
   staticFields = fields.Where(f => f.IsStatic),
  
   t.TypesUsed,

   // Constant Debt estimation, since for such type rules in category "Code Quality" 
   // accurately estimate the Debt.
   Debt     = 10.ToMinutes().ToDebt(),

   // The Severity is higher for new types than for refactored types 
   AnnualInterest= (t.WasAdded() ? 3 : 1) *
                    Severity.High.AnnualInterestThreshold()
}

//<Description>
// This rule is executed only if a *baseline for comparison* is defined (*diff mode*).
// This rule operates only on types added since baseline.
//
// This rule can be easily modified to also match types refactored since baseline,
// that don't satisfy all quality criterions.
//
// Types matched by this rule not only have been recently added or refactored,
// but also somehow violate one or several basic quality principles,
// whether it has too many methods,
// it has too many fields,
// or is using too many types.
// Any of these criterions is often a symptom of a type with too many responsibilities.
//
// Notice that to count methods and fields, methods like constructors 
// or property and event accessors are not taken account.
// Notice that constants fields and static-readonly fields are not counted.
// Enumerations types are not counted also.
//</Description>

//<HowToFix>
// To refactor such type and increase code quality and maintainability,
// certainly you'll have to split the type into several smaller types
// that together, implement the same logic.
//
// Issues of this rule have a constant 10 minutes Debt, because the Debt,
// which means the effort to fix such issue, is already estimated for issues
// of rules in the category **Code Quality**.
//
// However issues of this rule have a **Major** severity, with even more 
// interests for issues on new types since baseline, because the proper time 
// to increase the quality of these types is **now**, before they get commited 
// in the next production release.
//</HowToFix>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>From now, all types added should be 100% covered by tests</Name>
warnif count > 0 from t in JustMyCode.Types where

// Only match types added since Baseline.
// Uncomment this line to match also refactored types since Baseline.
// (t.WasAdded() || t.CodeWasChanged()) &&
   t.WasAdded() &&

  // …that are not 100% covered by tests
  t.PercentageCoverage < 100

  let methodsCulprit = t.Methods.Where(m => m.PercentageCoverage < 100)

select new { 
   t, 
   t.PercentageCoverage, 
   methodsCulprit,
   t.NbLinesOfCode,

   // Constant Debt estimation, since for such type rules in category "Coverage" 
   // accurately estimate the untested code Debt.
   Debt     = 10.ToMinutes().ToDebt(),

   // The Severity is higher for new types than for refactored types 
   AnnualInterest= (t.WasAdded() ? 3 : 1) *
                    Severity.High.AnnualInterestThreshold()
}

//<Description>
// This rule is executed only if a *baseline for comparison* is defined (*diff mode*).
// This rule operates only on types added since baseline.
//
// This rule can be easily modified to also match types refactored since baseline,
// that are not 100% covered by tests.
//
// This rule is executed only if some code coverage data is imported
// from some code coverage files.
//
// Often covering 10% of remaining uncovered code of a class, 
// requires as much work as covering the first 90%.
// For this reason, typically teams estimate that 90% coverage is enough.
// However *untestable code* usually means *poorly written code* 
// which usually leads to *error prone code*.
// So it might be worth refactoring and making sure to cover the 10% remaining code
// because **most tricky bugs might come from this small portion of hard-to-test code**.
//
// Not all classes should be 100% covered by tests (like UI code can be hard to test)
// but you should make sure that most of the logic of your application
// is defined in some *easy-to-test classes*, 100% covered by tests.
//
// In this context, this rule warns when a type added or refactored since the baseline,
// is not fully covered by tests.
//</Description>

//<HowToFix>
// Write more unit-tests dedicated to cover code not covered yet.
// If you find some *hard-to-test code*, it is certainly a sign that this code
// is not *well designed* and hence, needs refactoring.
//
// You'll find code impossible to cover by unit-tests, like calls to *MessageBox.Show()*.
// An infrastructure must be defined to be able to *mock* such code at test-time.
//
// Issues of this rule have a constant 10 minutes Debt, because the Debt,
// which means the effort to write tests for the culprit type, is already 
// estimated for issues in the category **Code Coverage**. 
//
// However issues of this rule have a **Major** severity, with even more 
// interests for issues on new types since baseline, because the proper time 
// to write tests for these types is **now**, before they get commited 
// in the next production release.
//</HowToFix>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>From now, all methods added should respect basic quality principles</Name>
warnif count > 0 from m in JustMyCode.Methods where

// Only match methods added since Baseline.
// Uncomment this line to match also refactored methods since Baseline.
// (m.WasAdded() || m.CodeWasChanged()) &&
   m.WasAdded() &&
 
// Low Quality methods// Metrics' definitions
(  m.NbLinesOfCode > 30 ||          // http://www.jarchitect.com/docs/code-metrics#NbLinesOfCode
   m.NbBCInstructions > 200 ||      // http://www.jarchitect.com/docs/code-metrics#NbBCInstructions
   m.CyclomaticComplexity > 20 ||   // http://www.jarchitect.com/docs/code-metrics#CC
   m.BCCyclomaticComplexity > 50 || // http://www.jarchitect.com/docs/code-metrics#ILCC
   m.BCNestingDepth > 4 ||          // http://www.jarchitect.com/docs/code-metrics#BCNestingDepth
   m.NbParameters > 5 ||            // http://www.jarchitect.com/docs/code-metrics#NbParameters
   m.NbVariables > 8 ||             // http://www.jarchitect.com/docs/code-metrics#NbVariables
   m.NbOverloads > 6 )
select new { 
   m, 
   m.NbLinesOfCode,
   m.NbBCInstructions,
   m.CyclomaticComplexity, 
   m.BCCyclomaticComplexity,
   m.BCNestingDepth, 
   m.NbParameters, 
   m.NbVariables, 
   m.NbOverloads, // http://www.jarchitect.com/docs/code-metrics#NbOverloads

   // Constant Debt estimation, since for such method rules in category "Code Quality" 
   // accurately estimate the Debt.
   Debt     = 5.ToMinutes().ToDebt(),

   // The Severity is higher for new methods than for refactored methods
   AnnualInterest= (m.WasAdded() ? 3 : 1) *
                   Severity.High.AnnualInterestThreshold()
}  

//<Description>
// This rule is executed only if a *baseline for comparison* is defined (*diff mode*).
// This rule operates only on methods added or refactored since the baseline.
//
// This rule can be easily modified to also match methods refactored since baseline,
// that don't satisfy all quality criterions.
//
// Methods matched by this rule not only have been recently added or refactored,
// but also somehow violate one or several basic quality principles,
// whether it is too large (too many *lines of code*), 
// too complex (too many *if*, *switch case*, loops…)
// has too many variables, too many parameters
// or has too many overloads.
//</Description>

//<HowToFix>
// To refactor such method and increase code quality and maintainability,
// certainly you'll have to split the method into several smaller methods
// or even create one or several classes to implement the logic.
//
// During this process it is important to question the scope of each
// variable local to the method. This can be an indication if
// such local variable will become an instance field of the newly created class(es).
//
// Large *switch…case* structures might be refactored through the help
// of a set of types that implement a common interface, the interface polymorphism
// playing the role of the *switch cases tests*.
//
// Unit Tests can help: write tests for each method before extracting it 
// to ensure you don't break functionality.
//
// Issues of this rule have a constant 5 minutes Debt, because the Debt,
// which means the effort to fix such issue, is already estimated for issues
// of rules in the category **Code Quality**.
// 
// However issues of this rule have a **Major** severity, with even more 
// interests for issues on new methods since baseline, because the proper time 
// to increase the quality of these methods is **now**, before they get commited 
// in the next production release.
//</HowToFix>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Avoid decreasing code coverage by tests of types</Name>
warnif count > 0 
from t in JustMyCode.Types where
  t.IsPresentInBothBuilds() && t.CoverageDataAvailable && t.OlderVersion().CoverageDataAvailable
let locDiff = (int)t.NbLinesOfCode.Value - (int)t.OlderVersion().NbLinesOfCode.Value
where locDiff >= 0
let uncoveredLoc  = (int)t.NbLinesOfCodeNotCovered.Value - ((int)t.OlderVersion().NbLinesOfCodeNotCovered.Value + locDiff)
where uncoveredLoc > 0

orderby uncoveredLoc descending

select new { 
   t,
   OldCoverage = t.OlderVersion().PercentageCoverage,
   NewCoverage = t.PercentageCoverage,
   OldLoc = t.OlderVersion().NbLinesOfCode,
   NewLoc = t.NbLinesOfCode,
   uncoveredLoc,

   Debt = uncoveredLoc.Linear(1, 15,  100, 3*60).ToMinutes().ToDebt(),

   // The annual interest varies linearly from interest for severity Major for one line of code that is not covered by tests anymore
   // to interest for severity Critical for 50 lines of code that are not covered by tests anymore
   AnnualInterest = uncoveredLoc.Linear(1,    Severity.High.AnnualInterestThreshold().Value.TotalMinutes, 
                                        50, 2*Severity.Critical.AnnualInterestThreshold().Value.TotalMinutes).ToMinutes().ToAnnualInterest()
   

}

//<Description>
// This rule is executed only if a *baseline for comparison* is defined (*diff mode*).
//
// This rule is executed only if some code coverage data is imported
// from some code coverage files.
//
// This rule warns when the number of lines of a type covered by tests
// decreased since the baseline. In case the type faced some refactoring
// since the baseline, this loss in coverage is estimated only for types 
// with more lines of code, where # lines of code covered now is lower
// than # lines of code covered in baseline + the extra number of
// lines of code.
//
// Such situation can mean that some tests have been removed
// but more often, this means that the type has been modified,
// and that changes haven't been covered properly by tests.
//
// To visualize changes in code, right-click a matched type and select:
//
// • Compare older and newer versions of source file
//
// • or Compare older and newer versions disassembled with Reflector
//</Description>

//<HowToFix>
// Write more unit-tests dedicated to cover changes in matched types
// not covered yet.
// If you find some *hard-to-test code*, it is certainly a sign that this code
// is not *well designed* and hence, needs refactoring.
//
// The estimated Debt, which means the effort to cover by test 
// code that used to be covered, varies linearly 15 minutes to 3 hours,
// depending on the number of lines of code that are not covered by tests anymore.
//
// Severity of issues of this rule varies from **Major** to **Critical** 
// depending on the number of lines of code that are not covered by tests anymore.
// Because the loss in code coverage happened since the baseline,
// the severity is high because it is important to focus on these issues 
// **now**, before such code gets released in production.
//</HowToFix>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Avoid making complex methods even more complex</Name>
warnif count > 0 

let complexityScoreProc = new Func<IMethod, double>(m => 
    (m.CyclomaticComplexity + m.BCCyclomaticComplexity/3 + 5*m.BCNestingDepth).Value)

from m in JustMyCode.Methods where
 !m.IsAbstract &&
  m.IsPresentInBothBuilds() &&
  m.CodeWasChanged() &&
  m.OlderVersion().CyclomaticComplexity > 6 

let complexityScore = complexityScoreProc(m)
let oldComplexityScore = complexityScoreProc(m.OlderVersion())
where complexityScore > oldComplexityScore 

let complexityScoreDiff = complexityScoreProc(m) - complexityScoreProc(m.OlderVersion())
orderby complexityScoreDiff descending

select new { 
   m,
   oldComplexityScore ,
   complexityScore ,
   diff= complexityScoreDiff,

   Debt = complexityScoreDiff.Linear(1, 15,   50, 60).ToMinutes().ToDebt(),

   // The annual interest varies linearly from interest for severity Minor for a tiny complexity increment
   // to interest for severity critical for 2000 loc
   AnnualInterest = complexityScoreDiff.Linear(1,     Severity.High.AnnualInterestThreshold().Value.TotalMinutes, 
                                               50, 4*(Severity.High.AnnualInterestThreshold().Value.TotalMinutes)).ToMinutes().ToAnnualInterest()
   
}

//<Description>
// This rule is executed only if a *baseline for comparison* is defined (*diff mode*).
//
// The method complexity is measured through the code metric
// *Cyclomatic Complexity* defined here:
// http://www.jarchitect.com/docs/code-metrics#CC
//
// This rule warns when a method already complex
// (i.e with *Cyclomatic Complexity* higher than 6)
// become even more complex since the baseline.
//
// This rule needs Projects PDB files and source code 
// to be available at analysis time, because the *Cyclomatic Complexity*
// is inferred from the source code and source code location
// is inferred from PDB files. See:
// http://www.jarchitect.com/docs/jarchitect-analysis-inputs-explanation
//
// To visualize changes in code, right-click a matched method and select:
//
// • Compare older and newer versions of source file
//
// • or Compare older and newer versions disassembled with Reflector
//</Description>

//<HowToFix>
// A large and complex method should be split in smaller methods, 
// or even one or several classes can be created for that.
//
// During this process it is important to question the scope of each
// variable local to the method. This can be an indication if
// such local variable will become an instance field of the newly created class(es).
//
// Large *switch…case* structures might be refactored through the help
// of a set of types that implement a common interface, the interface polymorphism
// playing the role of the *switch cases tests*.
//
// Unit Tests can help: write tests for each method before extracting it 
// to ensure you don't break functionality.
//
// The estimated Debt, which means the effort to fix such issue,
// varies linearly from 15 to 60 minutes depending on the extra complexity added.
//
// Issues of this rule have a **Major** severity, because it is important to focus 
// on these issues **now**, before such code gets released in production.
//</HowToFix>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Avoid making large methods even larger</Name>

warnif count > 0 
from m in JustMyCode.Methods where
 !m.IsAbstract &&

 // Eliminate constructors from match, since they get larger
 // as soons as some fields initialization are added.
 !m.IsConstructor &&
 !m.IsClassConstructor &&

  // Filter just here for optimization
  m.NbLinesOfCode > 15 &&

  m.IsPresentInBothBuilds() &&
  m.CodeWasChanged() 

let oldLoc = m.OlderVersion().NbLinesOfCode
where oldLoc > 15 && m.NbLinesOfCode > oldLoc

let diff = m.NbLinesOfCode - oldLoc
where diff > 0
orderby diff descending 

select new { 
   m,
   oldLoc,
   newLoc = m.NbLinesOfCode,
   diff,

   Debt = diff.Linear(1, 10,   100, 60).ToMinutes().ToDebt(),

   // The annual interest varies linearly from interest for severity Minor for a tiny complexity increment
   // to interest for severity critical for 2000 loc
   AnnualInterest = diff .Linear(1,      Severity.High.AnnualInterestThreshold().Value.TotalMinutes, 
                                 100, 4*(Severity.High.AnnualInterestThreshold().Value.TotalMinutes)).ToMinutes().ToAnnualInterest()
   
}

//<Description>
// This rule is executed only if a *baseline for comparison* is defined (*diff mode*).
//
// This rule warns when a method already large
// (i.e with more than 15 lines of code)
// become even larger since the baseline.
//
// The method size is measured through the code metric
// *# Lines of Code* defined here:
// http://www.jarchitect.com/docs/code-metrics#NbLinesOfCode
//
// This rule needs Projects PDB files 
// to be available at analysis time, because the *# Lines of Code*
// is inferred from PDB files. See:
// http://www.jarchitect.com/docs/jarchitect-analysis-inputs-explanation
//
// To visualize changes in code, right-click a matched method and select:
//
// • Compare older and newer versions of source file
//
// • or Compare older and newer versions disassembled with Reflector
//</Description>

//<HowToFix>
// Usually too big methods should be split in smaller methods.
//
// But long methods with no branch conditions, that typically initialize some data,
// are not necessarily a problem to maintain, and might not need refactoring.
//
// The estimated Debt, which means the effort to fix such issue,
// varies linearly from 5 to 20 minutes depending 
// on the number of lines of code added.
//
// The estimated Debt, which means the effort to fix such issue,
// varies linearly from 10 to 60 minutes depending on the extra complexity added.
//
// Issues of this rule have a **Major** severity, because it is important to focus 
// on these issues **now**, before such code gets released in production.
//</HowToFix>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Avoid adding methods to a type that already had many methods</Name>

warnif count > 0 

// Don't count constructors and methods generated by the compiler!
let getMethodsProc = new Func<IType, IList<IMethod>>(
   t => t.Methods.Where(m =>
      !m.IsConstructor && !m.IsClassConstructor && 
      !m.IsGeneratedByCompiler).ToArray()) 


from t in JustMyCode.Types where
  
  t.NbMethods > 30 &&   // Just here for optimization

  t.IsPresentInBothBuilds()

  // Optimization: fast discard of non-relevant types
  where t.OlderVersion().NbMethods > 30

  let oldMethods = getMethodsProc(t.OlderVersion())
  where oldMethods.Count > 30

  let newMethods = getMethodsProc(t)
  where newMethods.Count > oldMethods.Count

  let addedMethods = newMethods.Where(m => m.WasAdded())
  let removedMethods = oldMethods.Where(m => m.WasRemoved())

  orderby addedMethods.Count() descending

select new { 
   t,
   nbOldMethods = oldMethods.Count,
   nbNewMethods = newMethods.Count,
   addedMethods,
   removedMethods,

   Debt           = (10*addedMethods.Count()).ToMinutes().ToDebt(),
   AnnualInterest =     addedMethods.Count().Linear(
          1,       Severity.Medium.AnnualInterestThreshold().Value.TotalMinutes, 
          100,  4*(Severity.High.AnnualInterestThreshold().Value.TotalMinutes)).ToMinutes().ToAnnualInterest()
}

//<Description>
// This rule is executed only if a *baseline for comparison* is defined (*diff mode*).
//
// Types where number of methods is greater than 15 
// might be hard to understand and maintain.
//
// This rule lists types that already had more than 15 methods
// at the baseline time, and for which new methods have been added.
//
// Having many methods for a type might be a symptom
// of too many responsibilities implemented.
//
// Notice that constructors and methods generated by the compiler 
// are not taken account.
//</Description>

//<HowToFix>
// To refactor such type and increase code quality and maintainability,
// certainly you'll have to split the type into several smaller types
// that together, implement the same logic.
//
// The estimated Debt, which means the effort to fix such issue,
// is equal to 10 minutes per method added.
//
// Issues of this rule have a **Major** severity, because it is important to focus 
// on these issues **now**, before such code gets released in production.
//</HowToFix>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Avoid adding instance fields to a type that already had many instance fields</Name>

warnif count > 0 

let getFieldsProc = new Func<IType, IList<IField>>(
   t => t.Fields.Where(f => 
          !f.IsLiteral &&
          !f.IsGeneratedByCompiler &&
          !f.IsStatic).ToArray()) 


from t in JustMyCode.Types where
  
 !t.IsEnumeration &&
  t.IsPresentInBothBuilds()

  // Optimization: fast discard of non-relevant types
  where t.OlderVersion().NbFields > 15

  let oldFields = getFieldsProc(t.OlderVersion())
  where oldFields.Count > 15

  let newFields = getFieldsProc(t)
  where newFields.Count > oldFields.Count

  let addedFields = newFields.Where(f => f.WasAdded())
  let removedFields = oldFields.Where(f => f.WasRemoved())

  orderby addedFields.Count() descending

select new { 
   t,
   nbOldFields = oldFields.Count,
   nbNewFields = newFields.Count,
   addedFields,
   removedFields,

   Debt           = (10*addedFields.Count()).ToMinutes().ToDebt(),
   AnnualInterest =     addedFields.Count().Linear(
          1,       Severity.High.AnnualInterestThreshold().Value.TotalMinutes, 
          100,  4*(Severity.High.AnnualInterestThreshold().Value.TotalMinutes)).ToMinutes().ToAnnualInterest()

}

//<Description>
// This rule is executed only if a *baseline for comparison* is defined (*diff mode*).
//
// Types where number of fields is greater than 15 
// might be hard to understand and maintain.
//
// This rule lists types that already had more than 15 fields
// at the baseline time, and for which new fields have been added.
//
// Having many fields for a type might be a symptom
// of too many responsibilities implemented.
//
// Notice that *constants* fields and *static-readonly* fields are not taken account.
// Enumerations types are not taken account also.
//</Description>

//<HowToFix>
// To refactor such type and increase code quality and maintainability,
// certainly you'll have to group subsets of fields into smaller types
// and dispatch the logic implemented into the methods 
// into these smaller types.
//
// The estimated Debt, which means the effort to fix such issue,
// is equal to 10 minutes per field added.
//
// Issues of this rule have a **Major** severity, because it is important to focus 
// on these issues **now**, before such code gets released in production.
//</HowToFix>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Avoid transforming an immutable type into a mutable one</Name>

warnif count > 0
from t in Application.Types where
   t.CodeWasChanged() &&
   t.OlderVersion().IsImmutable &&
  !t.IsImmutable && 
  // Don't take account of immutable types transformed into static types (not deemed as immutable)
  !t.IsStatic

let culpritFields = t.InstanceFields.Where(f => f.IsImmutable)
select new {
   t, 
   culpritFields,
   Debt = (10 + 10*culpritFields.Count()).ToMinutes().ToDebt(),
   Severity = Severity.High
}

//<Description>
// This rule is executed only if a *baseline for comparison* is defined (*diff mode*).
//
// A type is considered as *immutable* if its instance fields
// cannot be modified once an instance has been built by a constructor.
//
// Being immutable has several fortunate consequences for a type.
// For example its instance objects can be used concurrently 
// from several threads without the need to synchronize accesses.
//
// Hence users of such type often rely on the fact that the type is immutable.
// If an immutable type becomes mutable, there are chances that this will break 
// users code.
//
// This is why this rule warns about such immutable type that become mutable.
//
// The estimated Debt, which means the effort to fix such issue,
// is equal to 2 minutes per instance field that became mutable.
//</Description>

//<HowToFix>
// If being immutable is an important property for a matched type,
// then the code must be refactored to preserve immutability.
//
// The estimated Debt, which means the effort to fix such issue,
// is equal to 10 minutes plus 10 minutes per instance fields of
// the matched type that is now mutable.
//
// Issues of this rule have a **Major** severity, because it is important to focus 
// on these issues **now**, before such code gets released in production.
//</HowToFix>]]></Query>
    </Group>
    <Group Name="Object Oriented Design" Active="True" ShownInReport="True">
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Base class should not use derivatives</Name>
warnif count > 0 
from baseClass in JustMyCode.Types
where baseClass.IsClass && baseClass.NbChildren > 0 // <-- for optimization!
let derivedClassesUsed = baseClass.DerivedTypes.UsedBy(baseClass)
   // Don't warn when a base class is using nested private derived class
   .Where(derivedClass => 
            !(derivedClass.IsNested && 
              derivedClass.Visibility == Visibility.Private && 
              derivedClass.ParentType == baseClass))
where derivedClassesUsed.Count() > 0

let derivedClassesMemberUsed = derivedClassesUsed.SelectMany(c => c.Members).UsedBy(baseClass)
orderby derivedClassesMemberUsed.Count() descending

select new { 
   baseClass, 
   derivedClassesUsed,
   derivedClassesMemberUsed,

   Debt = 3*(derivedClassesUsed.Count()+derivedClassesMemberUsed.Count()).ToMinutes().ToDebt(),
   Severity = Severity.High
}

//<Description>
// In *Object-Oriented Programming*, the **open/closed principle** states:
// *software entities (components, classes, methods, etc.) should be open 
// for extension, but closed for modification*. 
// http://en.wikipedia.org/wiki/Open/closed_principle
//
// Hence a base class should be designed properly to make it easy to derive from,
// this is *extension*. But creating a new derived class, or modifying an
// existing one, shouldn't provoke any *modification* in the base class.
// And if a base class is using some derivative classes somehow, there
// are good chances that such *modification* will be needed.
//
// Extending the base class is not anymore a simple operation,
// this is not good design.
//
// Note that this rule doesn't warn when a base class is using a derived class 
// that is nested in the base class and declared as private. In such situation
// we consider that the derived class is an encapsulated implementation
// detail of the base class.
//</Description>

//<HowToFix>
// Understand the need for using derivatives, 
// then imagine a new design, and then refactor.
//
// Typically an algorithm in the base class needs to access something 
// from derived classes. You can try to encapsulate this access behind 
// an abstract or a virtual method.
//
// If you see in the base class some conditions on *typeof(DerivedClass)*
// not only *urgent refactoring* is needed. Such condition can easily 
// be replaced through an abstract or a virtual method.
//
// Sometime you'll see a base class that creates instance of some derived classes.
// In such situation, certainly using the *factory method pattern* 
// http://en.wikipedia.org/wiki/Factory_method_pattern
// or the *abstract factory pattern* 
// http://en.wikipedia.org/wiki/Abstract_factory_pattern
// will improve the design.
//
// The estimated Debt, which means the effort to fix such issue,
// is equal to 3 minutes per derived class used by the base class +
// 3 minutes per member of a derived class used by the base class.
//</HowToFix>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Class shouldn't be too deep in inheritance tree</Name>
warnif count > 0 from t in JustMyCode.Types 
where t.IsClass
let baseClasses = t.BaseClasses.ExceptThirdParty()
where baseClasses.Count() >= 3
orderby baseClasses.Count() descending

select new { 
   t, 
   baseClasses, 
   // The metric value DepthOfInheritance takes account
   // of third-party base classessee its definition here:
   // http://www.ndepend.com/docs/code-metrics#DIT
   t.DepthOfInheritance,
   Debt = (baseClasses.Count() -2)*3.ToMinutes().ToDebt(),
   Severity = Severity.Medium
} 

//<Description>
// This rule warns about classes having 3 or more base classes.
// Notice that third-party base classes are not counted
// because this rule is about your code design, not 
// third-party libraries consumed design.
//
// *In theory*, there is nothing wrong having a *long inheritance chain*,
// if the modelization has been well thought out,
// if each base class is a well-designed refinement of the domain.
//
// *In practice*, modeling properly a domain demands a lot of effort
// and experience and more often than not, a *long inheritance chain*
// is a sign of confused design, that will be hard to work with and maintain.
//</Description>

//<HowToFix>
// In *Object-Oriented Programming*, a well-known motto is
// **Favor Composition over Inheritance**.
//
// This is because *inheritance* comes with pitfalls.
// In general, the implementation of a derived class is very bound up with 
// the base class implementation. Also a base class exposes implementation
// details to its derived classes, that's why it's often said that 
// inheritance breaks encapsulation. 
//
// On the other hands, *Composition* favors binding with interfaces
// over binding with implementations. Hence, not only the encapsulation
// is preserved, but the design is clearer, because interfaces make it explicit
// and less coupled.
//
// Hence, to break a *long inheritance chain*, *Composition* is often
// a powerful way to enhance the design of the refactored underlying logic.
//
// You can also read: 
// http://en.wikipedia.org/wiki/Composition_over_inheritance and
// http://stackoverflow.com/questions/49002/prefer-composition-over-inheritance
//
// The estimated Debt, which means the effort to fix such issue,
// depends linearly upon the depth of inheritance.
//</HowToFix>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Don't assign static fields from instance methods</Name>
warnif count > 0
from f in Application.Fields where 
  f.IsStatic &&
 !f.IsLiteral &&
 !f.IsInitOnly &&
 !f.IsGeneratedByCompiler &&
  // Contract API define such a insideContractEvaluation static field
  f.Name != "insideContractEvaluation"
let assignedBy = f.MethodsAssigningMe.Where(m => !m.IsStatic)
where assignedBy .Count() > 0
select new { 
   f, 
   assignedBy,
   Debt = 5.ToMinutes().ToDebt(),
   Severity = Severity.Medium
}
     
//<Description>
// Assigning static fields from instance methods leads to
// poorly maintainable and non-thread-safe code.
//
// More discussion on the topic can be found here:
// http://codebetter.com/patricksmacchia/2011/05/04/back-to-basics-usage-of-static-members/
//</Description>

//<HowToFix>
// If the *static* field is just assigned once in the program
// lifetime, make sure to declare it as *readonly* and assign 
// it inline, or from the static constructor.
//
// In *Object-Oriented-Programming* the natural artifact 
// to hold states that can be modified is **instance fields**.
//
// Hence to fix violations of this rule, make sure to
// hold assignable states through *instance* fields, not
// through *static* fields.
//</HowToFix>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Avoid empty interfaces</Name>
warnif count > 0 from t in JustMyCode.Types where 
   t.IsInterface && 
   t.NbMethods == 0
select new { 
   t, 
   t.TypesThatImplementMe,
   Debt = (10 + 3*t.TypesThatImplementMe.Count()).ToMinutes().ToDebt(),
   Severity = t.TypesThatImplementMe.Any() ? Severity.Medium : Severity.Low
}

//<Description>
// Interfaces define members that provide 
// a behavior or usage contract. 
// The functionality that is described by the interface 
// can be adopted by any type, regardless of where the type 
// appears in the inheritance hierarchy. 
// A type implements an interface by providing implementations 
// for the members of the interface. 
// An empty interface does not define any members. 
// Therefore, it does not define a contract that can be implemented.
//
// If your design includes empty interfaces that types 
// are expected to implement, you are probably using an interface 
// as a marker or a way to identify a group of types. 
// If this identification will occur at run time, 
// the correct way to accomplish this is to use a custom attribute. 
// Use the presence or absence of the attribute, 
// or the properties of the attribute, to identify the target types. 
// If the identification must occur at compile time, 
// then it is acceptable to use an empty interface.
//</Description>

//<HowToFix>
// Remove the interface or add members to it. 
// If the empty interface is being used to label a set of types, 
// replace the interface with a custom attribute.
//
// The estimated Debt, which means the effort to fix such issue,
// is equal to 10 minutes to discard an empty interface plus
// 3 minutes per type implementing an empty interface.
//</HowToFix>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Nested types should not be visible</Name>
warnif count > 0 from t in JustMyCode.Types where 
  t.IsNested && 
 !t.IsGeneratedByCompiler &&
 !t.IsPrivate 
let typesUser = t.TypesUsingMe.Where(t1 => t1 != t.ParentType && t1.ParentType != t.ParentType)
select new { 
   t, 
   t.Visibility,
   typesUser,
   Debt = (2 + 4*typesUser.Count()).ToMinutes().ToDebt(),
   Severity = Severity.Medium
} 

//<Description>
// This rule warns about nested types not declared as private.
//
// A nested type is a type declared within the scope of another 
// type. Nested types are useful for encapsulating private 
// implementation details of the containing type. Used 
// for this purpose, nested types should not be externally visible.
//
// Do not use externally visible nested types for logical 
// grouping or to avoid name collisions; instead use namespaces.
//
// Nested types include the notion of member accessibility, 
// which some programmers do not understand clearly.
//
// Protected types can be used in subclasses and nested types 
// in advanced customization scenarios.
//</Description>

//<HowToFix>
// If you do not intend the nested type to be externally visible,
// change the type's accessibility. 
//
// Otherwise, remove the nested type from its parent and make it 
// *non-nested*.
//
// If the purpose of the nesting is to group some nested types, 
// use a namespace to create the hierarchy instead.
//
// The estimated Debt, which means the effort to fix such issue,
// is 2 minutes per nested type plus 4 minutes per outter type
// using such nesting type.
//</HowToFix>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Don't use obsolete types, methods or fields</Name>   
warnif count > 0
let obsoleteTypes =   Types.Where(t => t.IsObsolete)
let obsoleteMethods = Methods.Where(m => m.IsObsolete).ToHashSetEx()
let obsoleteFields =  Fields.Where(f => f.IsObsolete)

from m in JustMyCode.Methods.UsingAny(obsoleteTypes).Union(
          JustMyCode.Methods.UsingAny(obsoleteMethods)).Union(
          JustMyCode.Methods.UsingAny(obsoleteFields))
let obsoleteTypesUsed = obsoleteTypes.UsedBy(m)

// Optimization: MethodsCalled + Intersect() is faster than using obsoleteMethods.UsedBy()
let obsoleteMethodsUsed = m.MethodsCalled.Intersect(obsoleteMethods)
let obsoleteFieldsUsed = obsoleteFields.UsedBy(m)

let obsoleteUsage = obsoleteTypesUsed.Cast<IMember>().Concat(obsoleteMethodsUsed).Concat(obsoleteFieldsUsed)

select new {
   m, 
   obsoleteUsage,
   Debt = (5*obsoleteUsage.Count()).ToMinutes().ToDebt(),
   Severity = Severity.High
}

//<Description>
// The attribute *System.ObsoleteAttribute* is used to tag
// types, methods or fields of an API that clients shouldn't 
// use because these code elements will be removed sooner
// or later.
//
// This rule warns about methods that use a type, a method
// or a field, tagged with *System.ObsoleteAttribute*.
//</Description>

//<HowToFix>
// Typically when a code element is tagged with
// *System.ObsoleteAttribute*, a *workaround message*
// is provided to clients.
//
// This *workaround message* will tell you what to do
// to avoid using the obsolete code element.
//
// The estimated Debt, which means the effort to fix such issue,
// is 5 minutes per type, method or field used.
//
// Issues of this rule have a severity **High**
// because it is important to not rely anymore on obsolete code.
//</HowToFix>]]></Query>
    </Group>
    <Group Name="Architecture" Active="True" ShownInReport="False">
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Avoid packages dependency cycles</Name>
warnif count > 0

// Optimization: restraint application Projects set
// If some packages are mutually dependent
//  - They must be declared in the same project
//  - The parent project must ContainsPackageDependencyCycle
from project in Application.Projects
                 .Where(a => a.ContainsPackageDependencyCycle != null && 
                             a.ContainsPackageDependencyCycle.Value)

// Optimization: restraint packages set
// A package involved in a cycle necessarily have a null Level.
let packagesSuspect = project.ChildPackages.Where(n => n.Level == null)

// hashset is used to avoid iterating again on packages already caught in a cycle.
let hashset = new HashSet<IPackage>()


from suspect in packagesSuspect
   // By commenting in this line, the query matches all packages involved in a cycle.
   where !hashset.Contains(suspect)

   // Define 2 code metrics
   // • Packages depth of is using indirectly the suspect package.
   // • Packages depth of is used by the suspect package indirectly.
   // Note: for direct usage the depth is equal to 1.
   let packagesUserDepth = packagesSuspect.DepthOfIsUsing(suspect)
   let packagesUsedDepth = packagesSuspect.DepthOfIsUsedBy(suspect)

   // Select packages that are both using and used by packageSuspect
   let usersAndUsed = from n in packagesSuspect where 
                         packagesUserDepth[n] > 0 && 
                         packagesUsedDepth[n] > 0 
                      select n

   where usersAndUsed.Count() > 0

   // Here we've found package(s) both using and used by the suspect package.
   // A cycle involving the suspect package is found!
   let cycle = usersAndUsed.AppendEx(suspect)

   // Fill hashset with packages in the cycle.
   // .ToArray() is needed to force the iterating process.
   let unused1 = (from n in cycle let unused2 = hashset.Add(n) select n).ToArray()

select new { 
   suspect, 
   cycle,
   Severity = Severity.High
}

//<Description>
// This rule lists all *application package dependency cycles*.
// Each row shows a different cycle, indexed with one of the package entangled 
// in the cycle.
//
// To browse a cycle on the dependency graph or the dependency matrix, right click
// a cycle cell and export the matched packages to the dependency graph or matrix.
//
// In the matrix, dependency cycles are represented with red squares and black cells.
// To easily browse dependency cycles, the dependency matrix comes with an option:
// *Display Direct and Indirect Dependencies*
//
// Read our white books relative to partitioning code, 
// to know more about packages dependency cycles, and why avoiding them 
// is a *simple yet efficient* solution to clean the architecture of a code base.
// http://www.jarchitect.com/docs/white-books
//</Description>

//<HowToFix>
// Removing first pairs of *mutually dependent packages* will eliminate
// most *packages dependency cycles*. This is why it is recommended
// focusing on matches of the default rule 
// **Avoid packages mutually dependent** before dealing
// with the present rule.
//
// Once solving all *mutually dependent packages*, remaining cycles
// matched by the present rule necessarily involve 3 or more packages
// like in: *A is using B is using C is using A*.
// Such cycle can be broken by identifying which package should
// be at the *lower-level*. For example if B should be at the
// *lower-level*, then it means C should be at the *higher-level*
// and to break the cycle, you just have to remove the dependency
// from B to C, with a pattern described in the *HowToFix* section
// of the rule *Avoid packages mutually dependent*.
//
// The estimated Debt, which means the effort to fix such issue,
// doesn't depend on the cycle length. First because fixing the rule
// **Avoid packages mutually dependent** will fix most cycle reported
// here, second because even a long cycle can be broken by removing
// a few dependency.
//</HowToFix>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Projects with poor cohesion (RelationalCohesion)</Name>
warnif count > 0 from a in Application.Projects 

// Build the types list on which we want to check cohesion
// This is the project 'a' type, minus enumeration
// and types generated by the compiler.
let types = a.ChildTypes.Where(
   t => !t.IsGeneratedByCompiler &&
        !t.IsEnumeration)
        // Absolutly need ToHashet() to have fast Intersect() calls below.
        .ToHashSetEx()

// Relational Cohesion metrics is relevant only if there are enough types
where types.LongCount()> 20

// R is the total number of relationship between types of the Projects. 
let R = types.Sum(t => t.TypesUsed.Intersect(types).Count())

// Relational Cohesion formula
let relationalCohesion = (double)R / types.Count
where  
  
  (relationalCohesion  < 1.5 || 
   relationalCohesion  > 4.0)
select new { 
  a, 
  a.ChildTypes,
  relationalCohesion, 
  a.RelationalCohesion,
  Debt = 10.ToMinutes().ToDebt(),
  Severity = Severity.Low
}

//<Description>
// This rule computes the *Relational Cohesion* metric for
// the application Projects, and warns about wrong values.
// 
// The *Relational Cohesion* for an project, is the total number 
// of relationship between types of the Projects, divided 
// by the number of types. In other words it is the average
// number of types in the project used by a type in the project.
//
// As classes inside an project should be strongly related, 
// the cohesion should be high. On the other hand, a value 
// which is too high may indicate over-coupling. A good range 
// for *Relational Cohesion* is **1.5 to 4.0**.
//
// Notice that Projects with less than 20 types are ignored.
//</Description>

//<HowToFix>
// Matches of this present rule might reveal either Projects
// with specific coding constraints (like code generated that
// have particular structure) either issues in design.
//
// In the second case, large refactoring can be planned
// not to respect this rule in particular, but to increase
// the overall design and code maintainability.
//
// The severity of issues of this rule is **Info** because
// the code metric *Relational Cohesion* is an information 
// about the code structure state but **is not actionable**, 
// it doesn't tell precisely what to do obtain a better score.
//
// Fixing actionable issues of others **Architecture** and 
// **Code Quality** default rules will necessarily increase 
// the *Relational Cohesion* scores.
//</HowToFix>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Packages with poor cohesion (RelationalCohesion)</Name>
warnif count > 0 from n in Application.Packages 

// Build the types list on which we want to check cohesion
// This is the package children types, minus enumerations
// and types generated by the compiler.
let types = n.ChildTypes.Where(
   t => !t.IsGeneratedByCompiler &&
        !t.IsEnumeration)
        // Absolutly need ToHashet() to have fast Intersect() calls below.
        .ToHashSetEx()

// Relational Cohesion metrics is relevant only if there are enough types
where types.LongCount() > 20

// R is the total number of relationship between types of the packages. 
let R = types.Sum(t => t.TypesUsed.Intersect(types).Count())

// Relational Cohesion formula
let relationalCohesion = (double)R / types.Count
where  
  (relationalCohesion  < 1.5 || 
   relationalCohesion  > 4.0)
select new { 
  n, 
  n.ChildTypes,
  relationalCohesion,
  Debt = 10.ToMinutes().ToDebt(),
  Severity = Severity.Low
}

//<Description>
// This rule computes the *Relational Cohesion* metric for
// the application packages, and warns about wrong values.
// 
// The *Relational Cohesion* for a package, is the total number 
// of relationship between types of the packages, divided 
// by the number of types. In other words it is the average
// number of types in the package used by a type in the package.
//
// As classes inside an package should be strongly related, 
// the cohesion should be high. On the other hand, a value 
// which is too high may indicate over-coupling. A good range 
// for *Relational Cohesion* is **1.5 to 4.0**.
//
// Notice that packages with less than 20 types are ignored.
//</Description>

//<HowToFix>
// Matches of this present rule might reveal either packages
// with specific coding constraints (like code generated that
// have particular structure) either issues in design.
//
// In the second case, refactoring sessions can be planned
// to increase the overall design and code maintainability.
//
// The severity of issues of this rule is **Info** because
// the code metric *Relational Cohesion* is an information 
// about the code structure state but **is not actionable**, 
// it doesn't tell precisely what to do obtain a better score.
//
// Fixing actionable issues of others **Architecture** and 
// **Code Quality** default rules will necessarily increase 
// the *Relational Cohesion* scores.
//</HowToFix>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Projects that don't satisfy the Abstractness/Instability principle</Name>
warnif count > 0 from a in Application.Projects 
  where a.NormDistFromMainSeq > 0.7
  orderby a.NormDistFromMainSeq descending
select new { 
   a,
   a.NormDistFromMainSeq,
   Debt = 10.ToMinutes().ToDebt(),
   Severity = Severity.Low
}

//<Description>
// The **Abstractness versus Instability Diagram** that is shown in the NDepend 
// report helps to assess which Projects are **potentially painful to maintain**
// (i.e concrete and stable) and which Projects are **potentially useless** 
// (i.e abstract and instable).
//
// • **Abstractness**: If an project contains many abstract types 
// (i.e interfaces and abstract classes) and few concrete types, 
// it is considered as abstract.
//
// • **Stability**: An project is considered stable if its types 
// are used by a lot of types from other Projects. In this context 
// stable means *painful to modify*.
//
// From these metrics, we define the *perpendicular normalized distance of
// an project from the idealized line* **A + I = 1** (called *main sequence*). 
// This metric is an indicator of the project's balance between abstractness 
// and stability. We precise that the word *normalized* means that the range 
// of values is [0.0 … 1.0].
//
// This rule warns about Projects with a *normalized distance* greater than 
// than 0.7.
//
// This rules use the default code metric on project
// *Normalized Distance from the Main Sequence* explained here: 
// http://www.jarchitect.com/docs/code-metrics#DitFromMainSeq
//
// These concepts have been originally introduced by *Robert C. Martin*
// in 1994 in this paper: http://www.objectmentor.com/resources/articles/oodmetrc.pdf
//</Description>

//<HowToFix>
// Violations of this rule indicate Projects with an improper 
// *abstractness / stability* balance.
//
// • Either the project is *potentially painful to maintain* (i.e is massively
// used and contains mostly concrete types). This can be fixed by creating 
// abstractions to avoid too high coupling with concrete implementations.
//
// • Either the project is *potentially useless* (i.e contains mostly
// abstractions and is not used enough). In such situation, the design
// must be reviewed to see if it can be enhanced.
//
// The severity of issues of this rule is **Info** because
// the *Abstractness/Instability principle* is an information 
// about the code structure state but **is not actionable**, 
// it doesn't tell precisely what to do obtain a better score.
//
// Fixing actionable issues of others **Architecture** and 
// **Code Quality** default rules will necessarily push 
// the *Abstractness/Instability principle* scores in the 
// right direction.
//</HowToFix>]]></Query>
      <Query Active="False" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Higher cohesion - lower coupling</Name>
// warnif count > 0 
let abstractPackages = JustMyCode.Packages.Where(
     n => n.ChildTypes.Where(t => !t.IsInterface && !t.IsEnumeration).Count() == 0
).ToHashSetEx()

let concretePackages = JustMyCode.Packages.Except(abstractPackages).ToHashSetEx()

from n in concretePackages
let packagesUsed = n.PackagesUsed.ExceptThirdParty()
let concretePackagesUsed = packagesUsed.Except(abstractPackages)
let abstractPackagesUsed = packagesUsed.Except(concretePackages)
orderby concretePackagesUsed.Count() descending
select new { 
   n, 
   concretePackagesUsed , 
   abstractPackagesUsed,
   // Debt = 50.ToMinutes().ToDebt(),
   // Severity = Severity.High
}

//<Description>
// It is deemed as a good software architecture practice to clearly separate
// *abstract* packages that contain only abstractions (interfaces, enumerations, delegates)
// from *concrete* packages, that contain classes and structures.
//
// Typically, the more concrete packages rely on abstract packages *only*,
// the more **Decoupled** is the architecture, and the more **Cohesive** are 
// classes inside concrete packages.
//
// The present code query defines sets of abstract and concrete packages
// and show for each concrete packages, which concrete and abstract packages 
// are used. 
//</Description>

//<HowToFix>
// This query can be transformed into a code rule, depending if you wish to 
// constraint your code structure *coupling / cohesion* ratio.
//</HowToFix>]]></Query>
      <Query Active="False" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Example of custom rule to check for dependency</Name>
warnif count > 0 from a in Projects
where 
a.IsUsing("Foo1.Foo2".AllowNoMatch().MatchPackage()) &&
(a.Name == @"Foo3")
select new { 
   a, 
   a.NbLinesOfCode,
   // Debt and Severity / Annual Interest can be modified to estimate well the
   // effort to fix the issue and the annual cost to leave the issue unfixed.
   Debt = 30.ToMinutes().ToDebt(),
   Severity = Severity.High
}
// the project Foo3
// shouldn't use directly 
// the package Foo3.Foo4
// because (TODO insert your reason)

//<Description>
// This rule is a **sample rule** that shows how to
// check if a particular dependency exists or not, 
// from a code element **A** to a code element **B**,
// **A** and **B** being an *Project*, a *Package*, a *Type*, 
// a *Method* or a *Field*, **A** and **B** being not 
// necessarily of same kind (i.e two Projects or 
// two Packages…).
//
// Such rule can be generated:
//
// • by right clicking the cell in the *Dependency Matrix* 
// with **B** in row and **A** in column,
//
// • or by right-clicking the concerned arrow in the *Dependency 
// Graph* from **A** to **B**,
//
// and in both cases, click the menu
// **Generate a code rule that warns if this dependency exists**
//
// The generated rule will look like this one.
// It is now up to you to adapt this rule to check exactly 
// your needs.
//</Description>

//<HowToFix>
// This is a *sample rule* there is nothing to fix *as is*. 
//</HowToFix>]]></Query>
    </Group>
    <Group Name="PMD Rules (PMD must be enabled)" Active="True" ShownInReport="False">
      <Group Name="Design" Active="True" ShownInReport="True">
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>A high number of imports can indicate a high degree of coupling within an object.</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="ExcessiveImports" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 10.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Avoid using implementation types; use the interface instead</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="LooseCoupling" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 10.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Use of type outside of package hierarchy is not recommended; use recommended classes instead</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="LoosePackageCoupling" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 10.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>All methods are static.  Consider using a utility class instead. Alternatively, you could add a private constructor or make the class abstract to silence this warning.</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="UseUtilityClass" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 10.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Avoid unnecessary if..then..else statements when returning booleans</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="SimplifyBooleanReturns" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 1.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Avoid unnecessary comparisons in boolean expressions</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="SimplifyBooleanExpressions" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 1.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Switch statements should have a default label</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="SwitchStmtsShouldHaveDefault" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 1.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Deeply nested if..then statements are hard to read</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="AvoidDeeplyNestedIfStmts" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 10.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Avoid reassigning parameters</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="AvoidReassigningParameters" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 2.ToMinutes().ToDebt(),
                          Severity =Severity.Low
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>A high ratio of statements to labels in a switch statement.  Consider refactoring.</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="SwitchDensity" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 10.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Overridable type called during object construction</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="ConstructorCallsOverridableMethod" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 2.ToMinutes().ToDebt(),
                          Severity =Severity.Low
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Avoid instantiation through private constructors from outside of the constructors class.</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="AccessorClassGeneration" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 5.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>This final field could be made static</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="FinalFieldCouldBeStatic" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 1.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Ensure that resources  are closed after use</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="CloseResource" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 2.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Non-static initializers are confusing</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="NonStaticInitializer" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 5.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>The default label should be the last label in a switch statement</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="DefaultLabelNotLastInSwitchStmt" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 1.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>A non-case label was present in a switch statement</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="NonCaseLabelInSwitchStatement" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 1.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>This call to Collection.toArray() may be optimizable</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="OptimizableToArrayCall" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 10.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Avoid equality comparisons with Double.NaN</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="BadComparison" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 10.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Avoid using equals() to compare against null</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="EqualsNull" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 2.ToMinutes().ToDebt(),
                          Severity =Severity.Low
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Avoid if (x != y) ..; else ..;</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="ConfusingTernary" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 10.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Avoid instantiating an object just to call getClass() on it; use the .class public member instead</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="InstantiationToGetClass" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 2.ToMinutes().ToDebt(),
                          Severity =Severity.Low
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Avoid idempotent operations (like assigning a variable to itself).</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="IdempotentOperations" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 2.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>When instantiating a SimpleDateFormat object, specify a Locale</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="SimpleDateFormatNeedsLocale" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 2.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Private field could be made final; it is only initialized in the declaration or constructor.</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="ImmutableField" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 1.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>When doing a String.toLowerCase()/toUpperCase() call, use a Locale</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="UseLocaleWithCaseConversions" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 5.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Avoid protected fields in a final class.  Change to private or package access.</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="AvoidProtectedFieldInFinalClass" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 1.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Possible unsafe assignment to a non-final static field in a constructor.</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="AssignmentToNonFinalStatic" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 2.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Class cannot be instantiated and does not provide any static methods or fields</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="MissingStaticMethodInNonInstantiatableClass" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 5.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Use block level rather than method level synchronization</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="AvoidSynchronizedAtMethodLevel" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 10.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>A switch statement does not contain a break</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="MissingBreakInSwitch" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 1.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Call Thread.notifyAll() rather than Thread.notify()</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="UseNotifyAllInsteadOfNotify" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 1.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>An instanceof check is being performed on the caught exception.  Create a separate catch clause for this exception type.</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="AvoidInstanceofChecksInCatchClause" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 10.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>This abstract class does not have any abstract methods</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="AbstractClassWithoutAbstractMethod" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 1.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>No need to check for null before an instanceof</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="SimplifyConditional" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 1.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Use equals() to compare object references.</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="CompareObjectsWithEquals" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 2.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Position literals first in String comparisons</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="PositionLiteralsFirstInComparisons" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 2.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Position literals first in String comparisons for EqualsIgnoreCase</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="PositionLiteralsFirstInCaseInsensitiveComparisons" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 2.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Consider simply returning the value vs storing it in local variable</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="UnnecessaryLocalBeforeReturn" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 2.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Singleton is not thread safe</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="NonThreadSafeSingleton" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 10.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Class contains multiple getInstance methods. Please review.</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="SingleMethodSingleton" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 2.ToMinutes().ToDebt(),
                          Severity =Severity.Low
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>getInstance method always creates a new object and hence does not comply to Singleton Design Pattern behaviour. Please review</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="SingletonClassReturningNewInstance" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 2.ToMinutes().ToDebt(),
                          Severity =Severity.Low
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Document empty method body</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="UncommentedEmptyMethodBody" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 5.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Document empty constructor</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="UncommentedEmptyConstructor" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 5.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>An Interface should be used only to model a behaviour; consider converting this to a class.</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="AvoidConstantsInterface" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 10.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Static DateFormatter objects should be accessed in a synchronized manner</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="UnsynchronizedStaticDateFormatter" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 10.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>New exception is thrown in catch block, original stack trace may be lost</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="PreserveStackTrace" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 5.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Substitute calls to size() == 0 (or size() != 0, size() > 0, size() < 1) with calls to isEmpty()</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="UseCollectionIsEmpty" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 5.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>A class which only has private constructors should be final</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="ClassWithOnlyPrivateConstructorsShouldBeFinal" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 2.ToMinutes().ToDebt(),
                          Severity =Severity.Low
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>An empty method in an abstract class should be abstract instead</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="EmptyMethodInAbstractClassShouldBeAbstract" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 2.ToMinutes().ToDebt(),
                          Severity =Severity.Low
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Perhaps a variable could be replaced by a local variable.</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="SingularField" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 5.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Return an empty array rather than null.</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="ReturnEmptyArrayRatherThanNull" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 2.ToMinutes().ToDebt(),
                          Severity =Severity.Low
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>No abstract method which means that the keyword is most likely used to prevent instantiation. Use a private or protected constructor instead.</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="AbstractClassWithoutAnyMethod" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 2.ToMinutes().ToDebt(),
                          Severity =Severity.Low
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>A switch with less than three branches is inefficient, use a if statement instead.</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="TooFewBranchesForASwitchStatement" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 10.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Use opposite operator instead of the logic complement operator.</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="LogicInversion" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 10.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Consider using varargs for methods or constructors which take an array the last parameter.</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="UseVarargs" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 2.ToMinutes().ToDebt(),
                          Severity =Severity.Low
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Fields should be declared at the top of the class, before any method declarations, constructors, initializers or inner classes.</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="FieldDeclarationsShouldBeAtStartOfClass" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 2.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Avoid protected methods in a final class that doesnt extend anything other than Object.  Change to private or package access.</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="AvoidProtectedMethodInFinalClassNotExtending" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 2.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Avoid constants in interfaces. Interfaces define types, constants are implementation details better placed in classes or enums. See Effective Java, item 19.</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="ConstantsInInterface" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 5.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
      </Group>
      <Group Name="Import Statements" Active="True" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Avoid duplicate imports</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="DuplicateImports" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 2.ToMinutes().ToDebt(),
                          Severity =Severity.Low
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Avoid importing anything from the package java.lang</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="DontImportJavaLang" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 2.ToMinutes().ToDebt(),
                          Severity =Severity.Low
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Avoid unused imports</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="UnusedImports" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 2.ToMinutes().ToDebt(),
                          Severity =Severity.Low
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>No need to import a type that lives in the same package</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="ImportFromSamePackage" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 1.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Too many static imports may lead to messy code</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="TooManyStaticImports" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 10.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Unnecessary use of fully qualified name due to existing import </Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="UnnecessaryFullyQualifiedName" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 2.ToMinutes().ToDebt(),
                          Severity =Severity.Low
                       }

                ]]></Query>
      </Group>
      <Group Name="Optimization" Active="True" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>The Parameter is not assigned and could be declared final</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="MethodArgumentCouldBeFinal" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 1.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Avoid instantiating new objects inside loops</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="AvoidInstantiatingObjectsInLoops" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 10.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Use ArrayList instead of Vector</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="UseArrayListInsteadOfVector" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 10.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>This call to String.startsWith can be rewritten using String.charAt(0)</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="SimplifyStartsWith" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 10.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Prefer StringBuffer over += for concatenating strings</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="UseStringBufferForStringAppends" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 10.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Use asList instead of tight loops</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="UseArraysAsList" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 10.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>System.arraycopy is more efficient</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="AvoidArrayLoops" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 10.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Unnecessary wrapper object creation</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="UnnecessaryWrapperObjectCreation" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 10.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Do not add empty strings</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="AddEmptyString" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 1.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Avoid using redundant field initializer</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="RedundantFieldInitializer" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 2.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Avoid declaring a variable if it is unreferenced before a possible exit point.</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="PrematureDeclaration" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 2.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
      </Group>
      <Group Name="Strict Exceptions" Active="True" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>A catch statement should never catch throwable since it includes errors.</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="AvoidCatchingThrowable" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 10.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>A method/constructor shouldnt explicitly throw java.lang.Exception</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="SignatureDeclareThrowsException" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 5.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Avoid using exceptions as flow control.</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="ExceptionAsFlowControl" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 5.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Avoid catching NullPointerException; consider removing the cause of the NPE.</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="AvoidCatchingNPE" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 5.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Avoid throwing raw exception types.</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="AvoidThrowingRawExceptionTypes" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 2.ToMinutes().ToDebt(),
                          Severity =Severity.Low
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Avoid throwing null pointer exceptions.</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="AvoidThrowingNullPointerException" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 2.ToMinutes().ToDebt(),
                          Severity =Severity.Low
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>A catch statement that catches an exception only to rethrow it should be avoided.</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="AvoidRethrowingException" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 5.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Exceptions should not extend java.lang.Error</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="DoNotExtendJavaLangError" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 10.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>A throw statement in a finally block makes the control flow hard to understand.</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="DoNotThrowExceptionInFinally" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 2.ToMinutes().ToDebt(),
                          Severity =Severity.Low
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>A catch statement that catches an exception only to wrap it in a new instance of the same type of exception and throw it should be avoided</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="AvoidThrowingNewInstanceOfSameException" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 10.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Avoid catching generic exceptions such as NullPointerException, RuntimeException, Exception in try-catch block</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="AvoidCatchingGenericException" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 10.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Avoid statements in a catch block that invoke accessors on the exception without using the information</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="AvoidLosingExceptionInformation" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 2.ToMinutes().ToDebt(),
                          Severity =Severity.Low
                       }

                ]]></Query>
      </Group>
      <Group Name="String and StringBuffer" Active="True" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Avoid instantiating String objects; this is usually unnecessary.</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="StringInstantiation" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 2.ToMinutes().ToDebt(),
                          Severity =Severity.Low
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Avoid calling toString() on String objects; this is unnecessary.</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="StringToString" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 2.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Avoid concatenating nonliterals in a StringBuffer/StringBuilder constructor or append().</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="InefficientStringBuffering" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 2.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Using equalsIgnoreCase() is cleaner than using toUpperCase/toLowerCase().equals().</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="UnnecessaryCaseChange" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 2.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>This is an inefficient use of StringBuffer.toString; call StringBuffer.length instead.</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="UseStringBufferLength" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 2.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Avoid appending characters as strings in StringBuffer.append.</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="AppendCharacterWithChar" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 2.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>StringBuffer (or StringBuilder).append is called consecutively without reusing the target variable.</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="ConsecutiveAppendsShouldReuse" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 10.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>StringBuffer (or StringBuilder).append is called  consecutive times with literal Strings. Use a single append with a single combined String.</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="ConsecutiveLiteralAppends" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 10.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>String.indexOf(char) is faster than String.indexOf(String).</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="UseIndexOfChar" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 2.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>String.trim().length()==0 is an inefficient way to validate an empty String.</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="InefficientEmptyStringCheck" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 10.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>StringBuffer constructor is initialized with size , but has some characters appended.</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="InsufficientStringBufferDeclaration" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 10.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>No need to call String.valueOf to append to a string.</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="UselessStringValueOf" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 10.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Do not instantiate a StringBuffer or StringBuilder with a char</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="StringBufferInstantiationWithChar" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 2.ToMinutes().ToDebt(),
                          Severity =Severity.Low
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Use equals() to compare strings instead of == or !=</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="UseEqualsToCompareStrings" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 10.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>StringBuffers can grow quite a lot, and so may become a source of memory leak (if the owning class has a long life time).</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="AvoidStringBufferField" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 10.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
      </Group>
      <Group Name="API Breaking Changes" Active="True" ShownInReport="True">
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="True"><![CDATA[// <Name>API Breaking Changes: Types</Name>

warnif count > 0 from t in codeBase.OlderVersion().Application.Types
where t.IsPubliclyVisible && 

     // The type has been removed, it was not tagged as obsolete
     // and its parent project hasn't been removed …
     ( ( t.WasRemoved() && 
        !t.ParentProject.WasRemoved() && 
        !t.IsObsolete) ||

     // … or the type is not publicly visible anymore
        !t.WasRemoved() && !t.NewerVersion().IsPubliclyVisible)

select new { 
   t,
   NewVisibility = 
      (t.WasRemoved() ? " " : 
       t.NewerVersion().Visibility.ToString()),
   Debt = 20.ToMinutes().ToDebt(),
   Severity = Severity.High
}

//<Description>
// This rule is executed only if a *baseline for comparison* is defined (*diff mode*).
//
// This rule warns if a type publicly visible in the *baseline*, 
// is not publicly visible anymore or if it has been removed.
// Clients code using such type will be broken.
//</Description>

//<HowToFix>
// Make sure that public types that used to be presented to
// clients, still remain public now, and in the future.
//
// If a public type must really be removed, you can tag it
// with *System.ObsoleteAttribute* with a *workaround message*
// during a few public releases, until it gets removed definitely.
// Notice that this rule doesn't match types removed that were
// tagged as obsolete.
//
// Issues of this rule have a severity equal to **Major**
// because an API Breaking change can provoque significant
// friction with consumers of the API.
//</HowToFix>]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="True"><![CDATA[// <Name>API Breaking Changes: Methods</Name>
warnif count > 0 from m in codeBase.OlderVersion().Application.Methods
where m.IsPubliclyVisible && 

     // The method has been removed, it was not tagged as obsolete
     // and its parent type hasn't been removed …
     ( ( m.WasRemoved() && 
        !m.ParentType.WasRemoved() && 
        !m.IsObsolete )

        // … or the method is not publicly visible anymore
     || (!m.WasRemoved() && !m.NewerVersion().IsPubliclyVisible) 

        // … or the method return type has changed
     || (!m.WasRemoved() && m.ReturnType != null && m.NewerVersion().ReturnType != null
                         && m.ReturnType.FullName != m.NewerVersion().ReturnType.FullName)        
      )

//--------------------------------------
// Handle special case: if between two versions a regular property becomes 
// an auto-property (or vice-versa) the property getter/setter method have 
// a different value for IMethod.IsGeneratedByCompiler
// since auto-property getter/setter are marked as generated by the compiler.
//
// If a method IsGeneratedByCompiler value changes between two versions, 
// NDepend doesn't pair the newer/older occurences of the method.
//
// Hence in such situation, a public method is seen as added 
// and a public method is seen as removed, but the API is not broken!
// The equivalentMethod-check below avoids reporting such 
// API Breaking Change false-positive.
let equivalentMethod = m.WasRemoved() && m.ParentType.IsPresentInBothBuilds() ?
   m.ParentType.NewerVersion().Methods
   .FirstOrDefault(m1 => 
       m1.IsPubliclyVisible &&
       m1.Name == m.Name &&
       m1.IsGeneratedByCompiler != m.IsGeneratedByCompiler &&
      (m1.ReturnType == null || m.ReturnType == null || m1.ReturnType.FullName == m.ReturnType.FullName)
    )
    : null
where equivalentMethod == null
//--------------------------------------


select new { 
   m,
   NewVisibility = 
      (m.WasRemoved() ? " " : 
       m.NewerVersion().Visibility.ToString()),
   Debt = 10.ToMinutes().ToDebt(),
   Severity = Severity.High
}

//<Description>
// This rule is executed only if a *baseline for comparison* is defined (*diff mode*).
//
// This rule warns if a method publicly visible in the *baseline*, 
// is not publicly visible anymore or if it has been removed.
// Clients code using such method will be broken.
//</Description>

//<HowToFix>
// Make sure that public methods that used to be presented to
// clients, still remain public now, and in the future.
//
// If a public method must really be removed, you can tag it
// with *System.ObsoleteAttribute* with a *workaround message*
// during a few public releases, until it gets removed definitely.
// Notice that this rule doesn't match methods removed that were
// tagged as obsolete.
//
// Issues of this rule have a severity equal to **Major**
// because an API Breaking change can provoque significant
// friction with consumers of the API.
//</HowToFix>
]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="True"><![CDATA[// <Name>API Breaking Changes: Fields</Name>
warnif count > 0 from f in codeBase.OlderVersion().Application.Fields
where f.IsPubliclyVisible &&

     // The field has been removed, it was not tagged as obsolete
     // and its parent type hasn't been removed …
     ( ( f.WasRemoved() && 
        !f.ParentType.WasRemoved() && 
        !f.IsObsolete)

     // … or the field is not publicly visible anymore
     ||  !f.WasRemoved() && !f.NewerVersion().IsPubliclyVisible)

     // … or the field type has changed
     || (!f.WasRemoved() && f.FieldType != null && f.NewerVersion().FieldType != null
                         && f.FieldType.FullName != f.NewerVersion().FieldType.FullName)

select new { 
   f,
   NewVisibility = 
      (f.WasRemoved() ? " " : 
       f.NewerVersion().Visibility.ToString()),
   Debt = 10.ToMinutes().ToDebt(),
   Severity = Severity.High
}

//<Description>
// This rule is executed only if a *baseline for comparison* is defined (*diff mode*).
//
// This rule warns if a field publicly visible in the *baseline*, 
// is not publicly visible anymore or if it has been removed.
// Clients code using such field will be broken.
//</Description>

//<HowToFix>
// Make sure that public fields that used to be presented to
// clients, still remain public now, and in the future.
//
// If a public field must really be removed, you can tag it
// with *System.ObsoleteAttribute* with a *workaround message*
// during a few public releases, until it gets removed definitely.
// Notice that this rule doesn't match fields removed that were
// tagged as obsolete.
//
// Issues of this rule have a severity equal to **Major**
// because an API Breaking change can provoque significant
// friction with consumers of the API.
//</HowToFix>]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="True"><![CDATA[// <Name>API Breaking Changes: Interfaces and Abstract Classes</Name>
warnif count > 0 from tNewer in Application.Types where 
 (tNewer.IsInterface || tNewer.IsClass && tNewer.IsAbstract) && 
  tNewer.IsPubliclyVisible && 
  tNewer.IsPresentInBothBuilds()

let tOlder = tNewer.OlderVersion() where tOlder.IsPubliclyVisible

let methodsRemoved = tOlder.Methods.Where(m => m.IsAbstract && m.WasRemoved())
let methodsAdded = tNewer.Methods.Where(m => m.IsAbstract && m.WasAdded())

where methodsAdded.Count() > 0 || methodsRemoved.Count() > 0
select new { 
   tNewer, 
   methodsAdded, 
   methodsRemoved,
   Debt = 10.ToMinutes().ToDebt(),
   Severity = Severity.High
}

//<Description>
// This rule is executed only if a *baseline for comparison* is defined (*diff mode*).
//
// This rule warns if a publicly visible interface or abstract class 
// has been changed and contains new abstract methods or 
// if some abstract methods have been removed.
//
// Clients code that implement such interface or derive from 
// such abstract class will be broken.
//</Description>

//<HowToFix>
// Make sure that the public contracts of interfaces and abstract classes
// that used to be presented to clients, remain stable now, and in the future.
//
// If a public contract must really be changed, you can tag 
// abstract methods that will be removed with *System.ObsoleteAttribute*  
// with a *workaround message* during a few public releases, until it gets 
// removed definitely.
//
// Issues of this rule have a severity equal to **Major**
// because an API Breaking change can provoque significant
// friction with consummers of the API.
// The severity is not set to **Critical** because an interface 
// is not necessarily meant to be implemented by the consummer
// of the API.
//</HowToFix>]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="True"><![CDATA[// <Name>Broken serializable types</Name>
warnif count > 0

from t in Application.Types where

  // Collect types tagged with SerializableAttribute
  t.HasAnnotation("System.SerializableAttribute".AllowNoMatch())  &&
  t.IsPresentInBothBuilds() &&
  t.HasAnnotation(t)

  // Find newer and older versions of NonSerializedAttribute
  let newNonSerializedAttribute = ThirdParty.Types.WithFullName("System.NonSerializedAttribute").SingleOrDefault()
  let oldNonSerializedAttribute = newNonSerializedAttribute == null ? null : newNonSerializedAttribute.OlderVersion()

  // Find added or removed fields not marked with NonSerializedAttribute
  let addedInstanceField = from f in t.InstanceFields where 
                             f.WasAdded() && 
                             (newNonSerializedAttribute == null || !f.HasAnnotation(newNonSerializedAttribute))
                           select f
  let removedInstanceField = from f in t.OlderVersion().InstanceFields where 
                             f.WasRemoved() && 
                             (oldNonSerializedAttribute == null || !f.HasAnnotation(oldNonSerializedAttribute))
                           select f
  where addedInstanceField.Count() > 0 || removedInstanceField.Count() > 0

select new { 
   t, 
   addedInstanceField, 
   removedInstanceField,
   Debt = 20.ToMinutes().ToDebt(),
   Severity = Severity.Critical
}

//<Description>
// This rule is executed only if a *baseline for comparison* is defined (*diff mode*).
//
// This rule warns about breaking changes in types tagged with 
// *SerializableAttribute*.
//
// To do so, this rule searches for serializable type with serializable 
// instance fields added or removed. Notice that it doesn't take account
// of fields tagged with *NonSerializedAttribute*.
//
// From http://msdn.microsoft.com/library/system.serializableattribute.aspx :
// "All the public and private fields in a type that are marked by the 
//  *SerializableAttribute*  are serialized by default, unless the type 
//  implements the *ISerializable* interface to  override the serialization process. 
//  The default serialization process excludes fields that are marked 
//  with the *NonSerializedAttribute* attribute."
//</Description>

//<HowToFix>
// Make sure that the serialization process of serializable types remains
// stable now, and in the future.
// 
// Else you'll have to deal with **Version Tolerant Serialization**
// that is explained here:
// https://msdn.microsoft.com/en-us/library/ms229752(v=vs.110).aspx
//
// Issues of this rule have a severity equal to **Major**
// because an API Breaking change can provoque significant
// friction with consummers of the API.
//</HowToFix>]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="True"><![CDATA[// <Name>Avoid changing enumerations Flags status</Name>
warnif count > 0 

let oldFlags = codeBase.OlderVersion().ThirdParty.Types.WithFullName("System.FlagsAttribute").SingleOrDefault()
let newFlags = ThirdParty.Types.WithFullName("System.FlagsAttribute").SingleOrDefault()
where oldFlags != null && newFlags != null

from t in Application.Types where
   t.IsEnumeration &&
   t.IsPresentInBothBuilds() 
let hasFlagsAttributeNow = t.HasAnnotation(newFlags)
let usedToHaveFlagsAttribute = t.OlderVersion().HasAnnotation(oldFlags) 
where hasFlagsAttributeNow != usedToHaveFlagsAttribute
select new { 
   t, 
   hasFlagsAttributeNow, 
   usedToHaveFlagsAttribute,
   Debt = 10.ToMinutes().ToDebt(),
   Severity = Severity.High
}

//<Description>
// This rule is executed only if a *baseline for comparison* is defined (*diff mode*).
//
// This rule matches enumeration types that used to be tagged
// with *FlagsAttribute* in the *baseline*, and not anymore.
// It also matches the opposite, enumeration types that are now
// tagged with *FlagsAttribute*, and were not tagged in the *baseline*.
//
// Being tagged with *FlagsAttribute* is a strong property for an enumeration.
// Not so much in terms of *behavior* (only the *enum.ToString()* method
// behavior changes when an enumeration is tagged with *FlagsAttribute*)
// but in terms of *meaning*: is the enumeration a **range of values**
// or a **range of flags**?
//
// As a consequence, changing the *FlagsAttribute*s status of an enumeration can 
// have significant impact for its clients.
//</Description>

//<HowToFix>
// Make sure the *FlagsAttribute* status of each enumeration remains stable
// now, and in the future.
//</HowToFix>]]></Query>
        <Query Active="False" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>API: New publicly visible types</Name>
from t in Application.Types
where t.IsPubliclyVisible && 

     // The type has been removed and its parent project hasn't been removed …
     ( (t.WasAdded() && !t.ParentProject.WasAdded()) ||

     // … or the type existed but was not publicly visible
       !t.WasAdded() && !t.OlderVersion().IsPubliclyVisible)

select new { 
   t,
   OldVisibility = 
      (t.WasAdded() ? " " : 
       t.OlderVersion().Visibility.ToString()),
}

//<Description>
// This query is executed only if a *baseline for comparison* is defined (*diff mode*).
//
// This code query lists types that are new in the public 
// surface of the analyzed Projects.
//</Description>]]></Query>
        <Query Active="False" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>API: New publicly visible methods</Name>
from m in Application.Methods
where m.IsPubliclyVisible && 

     // The method has been removed and its parent project hasn't been removed …
     ( (m.WasAdded() && !m.ParentType.WasAdded()) ||

     // … or the method existed but was not publicly visible
       !m.WasAdded() && !m.OlderVersion().IsPubliclyVisible)

//--------------------------------------
// Handle special case: if between two versions a regular property becomes 
// an auto-property (or vice-versa) the property getter/setter method have 
// a different value for IMethod.IsGeneratedByCompiler
// since auto-property getter/setter are marked as generated by the compiler.
//
// If a method IsGeneratedByCompiler value changes between two versions, 
// NDepend doesn't pair the newer/older occurences of the method.
//
// Hence in such situation, a public method is seen as added 
// and a public method is seen as removed, but the API is not broken!
// The equivalentMethod-check below avoids reporting such 
// API Breaking Change false-positive.
let equivalentMethod = m.WasAdded() && m.ParentType.IsPresentInBothBuilds() ?
   m.ParentType.OlderVersion().Methods
   .FirstOrDefault(m1 => 
       m1.IsPubliclyVisible &&
       m1.Name == m.Name &&
       m1.IsGeneratedByCompiler != m.IsGeneratedByCompiler)
    : null
where equivalentMethod == null
//--------------------------------------

select new { 
   m,
   OldVisibility = 
      (m.WasAdded() ? " " : 
       m.OlderVersion().Visibility.ToString())
}

//<Description>
// This query is executed only if a *baseline for comparison* is defined (*diff mode*).
//
// This code query lists methods that are new in the public 
// surface of the analyzed Projects.
//</Description>
]]></Query>
        <Query Active="False" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>API: New publicly visible fields</Name>
from f in Application.Fields
where f.IsPubliclyVisible && 

     // The method has been removed and its parent project hasn'f been removed …
     ( (f.WasAdded() && !f.ParentType.WasAdded()) ||

     // … or the t existed but was not publicly visible
       !f.WasAdded() && !f.OlderVersion().IsPubliclyVisible)

select new { 
   f,
   OldVisibility = 
      (f.WasAdded() ? " " : 
       f.OlderVersion().Visibility.ToString())
}

//<Description>
// This query is executed only if a *baseline for comparison* is defined (*diff mode*).
//
// This code query lists fields that are new in the public 
// surface of the analyzed Projects.
//</Description>]]></Query>
      </Group>
      <Group Name="Code Coverage" Active="True" ShownInReport="True">
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Code should be tested</Name>
warnif count > 0

// This lambda infers a factor in the range [0,1] from a sequence of distinct types used,
// based on how many of these types are actually concrete (i.e are not interfaces or enumeration).
// Primitive types (int, bool...) are eliminated from the sequence of types used 
// by filtering types declared in the package System.
let abstractionUsageFactorFormula = new Func<IEnumerable<IType>,double>(typesUsed => 
            typesUsed.Count(t => t.ParentPackage.Name != "System" && !t.IsInterface && !t.IsEnumeration) 
     / (1 + typesUsed.Count(t => t.ParentPackage.Name != "System")))


from method in Application.Methods
  where !method.IsExcludedFromCoverage && method.NbLinesOfCode >= 0 && method.PercentageCoverage < 100 

  // Factor in case method is partially covered
  let uncoverageFactor = ((100 - method.PercentageCoverage) / 100).Value

  // Complexity factor
  let complexityFactor = ((method.CyclomaticComplexity ?? method.BCCyclomaticComplexity) + method.BCNestingDepth).Linear(0, 0.1,    10, 1).Value

  // Not my code is often generated code and is in general easier to get tested since test can be generated as well.
  let justMyCodeFactor = (JustMyCode.Contains(method) ? 1 : 0.4)

  // abstractionUsageFactor reflects the fact that code that relies on interfaces
  // is easier to test that code that relies on concrete classes.
  let abstractionUsageFactor = 0.7 + 0.3 *abstractionUsageFactorFormula(method.MembersUsed.Select(m => m.ParentType).Distinct())

  // The usageFactor depends on the method 'rank' that is a value
  // indicating if the method is often used or not
  let usageFactor = (method.Rank / (method.Rank + 4)).Value

  // It is more complicated to write tests for non publicly visible methods
  let visibilityFactor = method.Visibility.EqualsAny(Visibility.Public, Visibility.Internal) ? 1 : 
                         method.Visibility != Visibility.Private ? 1.1 : 1.2
  
  // Is is more complicated to write tests for methods that read mutable static fields 
  // whose changing state is shared across tests executions.
  let staticFieldUsageFactor = method.ReadsMutableTypeState ? 1.3 : 1.0


  // Both "effort to write tests" and "annual cost to not test" for a method
  // is determined by several factors in the range [0,1] that multiplies the effortToDevelop
  let effortToDevelopInMinutes = method.EffortToDevelop().Value.TotalMinutes

  let effortToWriteTests = Math.Max(2, // Minimum 2 minutes per method not tested
        effortToDevelopInMinutes * 
        uncoverageFactor * 
        complexityFactor * 
        justMyCodeFactor * 
        abstractionUsageFactor * 
        visibilityFactor *
        staticFieldUsageFactor).ToMinutes().ToDebt()

  let annualCostToNotFix = Math.Max(2, // Minimum 2 minutes per method not tested
        effortToDevelopInMinutes * 
        usageFactor *
        uncoverageFactor * 
        justMyCodeFactor).ToMinutes().ToAnnualInterest()
 
  orderby annualCostToNotFix.Value descending

select new { 
  method, 
  method.PercentageCoverage,
  method.NbLinesOfCode,
  method.NbLinesOfCodeNotCovered,
  method.CyclomaticComplexity,
  Debt = effortToWriteTests, 
  AnnualInterest = annualCostToNotFix,

  // BreakingPoint = effortToWriteTests.BreakingPoint(annualCostToNotFix),

  // Uncomment the line below to tinker with various factors
  //  uncoverageFactor, complexityFactor , justMyCodeFactor , abstractionUsageFactor, visibilityFactor, staticFieldUsageFactor 
}


//<Description>
// This rule lists methods not covered at all by test
// or partially covered by tests.
//
// For each match, the rules estimates the **technical debt**, i.e
// the effort to write unit and integration tests for the method.
// The estimation is based on the effort to develop the code element
// multiplied by factors in the range ]0,1.3] based on 
//
// • the method code size and complexity
//
// • the actual percentage coverage
//
// • the abstracness of types used, because relying on classes instead of 
// interfaces makes the code more difficult to test
//
// • the method visibility because testing private or protected
// methods is more difficult than testing public and internal ones
//
// • the fields used by the method, because is is more complicated to 
// write tests for methods that read mutable static fields whose changing 
// state is shared across tests executions.
//
// • whether the method is considered *JustMyCode* or not because *NotMyCode*
// is often generated easier to get tested since tests can be generated as well.
//
// This rule is necessarily a large source of technical debt, since
// the code left untested is by definition part of the technical debt.
//
// This rule also estimates the **annual interest**, i.e the annual cost 
// to let the code uncovered, based on the effort to develop the 
// code element, multiplied by factors based on usage of the code element.
//</Description>

//<HowToFix>
// Write unit tests to test and cover the methods and their parent classes
// matched by this rule.
//</HowToFix>]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>New Methods should be tested</Name>
warnif count > 0
from m in Application.Methods where
  m.NbLinesOfCode > 0 &&
  m.PercentageCoverage < 30 && 
  m.WasAdded() 
  orderby m.NbLinesOfCode descending, 
           m.NbLinesOfCodeNotCovered ,
           m.PercentageCoverage
select new { 
   m, 
   m.PercentageCoverage, 
   m.NbLinesOfCode, 
   m.NbLinesOfCodeNotCovered,

   // Simplistic Debt estimation, because the effort to write tests for a method not 100% tested
   // is already estimated properly with the rule "Code should be tested".
   Debt = m.NbLinesOfCodeNotCovered.Linear(1,2, 10,10).ToMinutes().ToDebt(),

   Severity = Severity.High
}

//<Description>
// This rule is executed only if a *baseline for comparison* is defined (*diff mode*).
// This rule operates only on methods added or refactored since the baseline.
//
// This rule is executed only if some code coverage data is imported
// from some code coverage files.
//
// It is important to write code mostly covered by tests 
// to achieve *maintainable* and *non-error-prone* code.
//
// In real-world, many code bases are poorly covered by tests.
// However it is not practicable to stop the development for months
// to refactor and write tests to achieve high code coverage ratio.
//
// Hence it is recommended that each time a method (or a type) gets added,
// the developer takes the time to write associated unit-tests to cover it.
//
// Doing so will help to increase significantly the maintainability of the code base.
// You'll notice that quickly, refactoring will also be driven by testability, 
// and as a consequence, the overall code structure and design will increase as well.
//
// Issues of this rule have a **Major** severity because they reflect
// an actual trend to not care about writing tests on refactored code.
//</Description>

//<HowToFix>
// Write unit-tests to cover the code of most methods and classes added.
//</HowToFix>]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Methods refactored should be tested</Name>
warnif count > 0
from m in Application.Methods where 
  m.PercentageCoverage < 30 && 
  m.CodeWasChanged() 
  orderby m.NbLinesOfCode descending, 
           m.NbLinesOfCodeNotCovered ,
           m.PercentageCoverage
select new {
   m, 
   m.PercentageCoverage,
   m.NbLinesOfCode, 
   m.NbLinesOfCodeNotCovered,

   // Simplistic Debt estimation, because the effort to write tests for a method not 100% tested
   // is already estimated properly with the rule "Code should be tested".
   Debt = m.NbLinesOfCodeNotCovered.Linear(1,2, 10,10).ToMinutes().ToDebt(),

   Severity = Severity.High
}  

//<Description>
// This rule is executed only if a *baseline for comparison* is defined (*diff mode*).
// This rule operates only on methods added or refactored since the baseline.
//
// This rule is executed only if some code coverage data is imported
// from some code coverage files.
//
// It is important to write code mostly covered by tests 
// to achieve *maintainable* and *non-error-prone* code.
//
// In real-world, many code bases are poorly covered by tests.
// However it is not practicable to stop the development for months
// to refactor and write tests to achieve high code coverage ratio.
//
// Hence it is recommended that each time a method (or a type) gets refactored,
// the developer takes the time to write associated unit-tests to cover it.
//
// Doing so will help to increase significantly the maintainability of the code base.
// You'll notice that quickly, refactoring will also be driven by testability, 
// and as a consequence, the overall code structure and design will increase as well.
//
// Issues of this rule have a **Major** severity because they reflect
// an actual trend to not care about writing tests on refactored code.
//</Description>

//<HowToFix>
// Write unit-tests to cover the code of most methods and classes refactored.
//</HowToFix>]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Projects Packages and Types should be tested</Name>
warnif count > 0
from elem in CodeElementParents
where elem.NbLinesOfCode > 0 &&
      elem.PercentageCoverage == 0 && 
      elem.Parent.PercentageCoverage != 0
orderby elem.NbLinesOfCode descending
select new { 
   elem, 
   elem.NbLinesOfCodeNotCovered,
   Debt = 4.ToMinutes().ToDebt(),
   Severity = Severity.Low
}

//<Description>
// This rule lists Projects, packages and types that are not
// covered at all by unit tests.
//
// If a parent is matched its children are not matched. For example
// if a package is matched, its child types are not matched.
//
// This rule goal is not to collide with the **Code should be tested**
// rule that lists uncovered code for each method and infer the effort
// to write unit tests (the *Debt*) and the annual cost to let the code
// untested (the Annual Interest).
//
// This rule goal is to inform of large code elements left untested.
// As a consequence the *Debt* per issue is only 4 minutes and the
// severity of the issues is *Info*.
//</Description>
//
//<HowToFix>
// Write unit and integration tests to cover, even partially, 
// code elements matched by this rule.
//
// Then use issues of the rules **Code should be tested**,
// **New Methods should be tested** and 
// **Methods refactored should be tested**
// to write more tests where it matters most, and eventually
// refactor some code to make it more testable.
//</HowToFix>]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Types almost 100% tested should be 100% tested</Name>
warnif count > 0
from t in Application.Types where 
  t.PercentageCoverage >= 95 && 
  t.PercentageCoverage <= 99 &&
 !t.IsGeneratedByCompiler

  let methodsCulprit = t.Methods.Where(m => m.PercentageCoverage < 100)

  orderby t.NbLinesOfCode descending , 
           t.NbLinesOfCodeNotCovered ,
           t.PercentageCoverage
select new { 
   t, 
   t.PercentageCoverage,
   t.NbLinesOfCode, 
   t.NbLinesOfCodeNotCovered, 
   methodsCulprit,

   // Simplistic Debt estimation, because the effort to write tests for a type not 100% tested
   // is already estimated properly with the rule "Code should be tested".
   Debt = t.NbLinesOfCodeNotCovered.Linear(1,2, 20,20).ToMinutes().ToDebt(),

   Severity = Severity.High
} 

//<Description>
// This rule is executed only if some code coverage data is imported
// from some code coverage files.
//
// Often covering the few percents of remaining uncovered code of a class, 
// requires as much work as covering the first 90%.
// For this reason, often teams estimate that 90% coverage is enough.
// However *untestable code* usually means *poorly written code* 
// which usually leads to *error prone code*.
// So it might be worth refactoring and making sure to cover the few uncovered lines of code
// **because most tricky bugs might come from this small portion of hard-to-test code**.
//
// Not all classes should be 100% covered by tests (like UI code can be hard to test)
// but you should make sure that most of the logic of your application
// is defined in some *easy-to-test classes*, 100% covered by tests.
//
// Issues of this rule have a **Major** severity because as explained,
// such situation is *bug-prone*.
//</Description>

//<HowToFix>
// Write more unit-tests dedicated to cover code not covered yet.
// If you find some *hard-to-test code*, it is certainly a sign that this code
// is not *well designed* and hence, needs refactoring.
//</HowToFix>]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Packages almost 100% tested should be 100% tested</Name>
warnif count > 0
from n in Application.Packages where 
  n.PercentageCoverage >= 95 && 
  n.PercentageCoverage <= 99 

  let methodsCulprit = n.ChildMethods.Where(m => m.PercentageCoverage < 100)

  orderby n.NbLinesOfCode descending , 
           n.NbLinesOfCodeNotCovered ,
           n.PercentageCoverage
select new { 
   n, 
   n.PercentageCoverage, 
   n.NbLinesOfCode, 
   n.NbLinesOfCodeNotCovered, 
   methodsCulprit,

   // Simplistic Debt estimation, because the effort to write tests for a type not 100% tested
   // is already estimated properly with the rule "Code should be tested".
   Debt = n.NbLinesOfCodeNotCovered.Linear(1,2, 50,60).ToMinutes().ToDebt(),

   Severity = Severity.High
} 

//<Description>
// This rule is executed only if some code coverage data is imported
// from some code coverage files.
//
// Often covering the few percents of remaining uncovered code of 
// one or several classes in a package
// requires as much work as covering the first 90%.
// For this reason, often teams estimate that 90% coverage is enough.
// However *untestable code* usually means *poorly written code* 
// which usually leads to *error prone code*.
// So it might be worth refactoring and making sure to cover the few uncovered lines of code
// **because most tricky bugs might come from this small portion of hard-to-test code**.
//
// Not all classes should be 100% covered by tests (like UI code can be hard to test)
// but you should make sure that most of the logic of your application
// is defined in some *easy-to-test classes*, 100% covered by tests.
//
// Issues of this rule have a **Major** severity because as explained,
// such situation is *bug-prone*.
//</Description>

//<HowToFix>
// Write more unit-tests dedicated to cover code not covered yet in the package.
// If you find some *hard-to-test code*, it is certainly a sign that this code
// is not *well designed* and hence, needs refactoring.
//</HowToFix>]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Types that used to be 100% covered by tests should still be 100% covered</Name>
        
warnif count > 0
from t in JustMyCode.Types where 
   t.IsPresentInBothBuilds() &&
   t.OlderVersion().PercentageCoverage == 100 &&
   t.PercentageCoverage < 100

from m in t .MethodsAndContructors where 
  m.NbLinesOfCode> 0 && 
  m.PercentageCoverage < 100 &&
 !m.IsExcludedFromCoverage

select new {
   m, 
   m.PercentageCoverage, 

   // Simplistic Debt estimation, because the effort to write tests for a method not 100% tested
   // is already estimated properly with the rule "Code should be tested".
   Debt = t.NbLinesOfCodeNotCovered.Linear(1,2, 10,10).ToMinutes().ToDebt(),

   Severity = Severity.High
}

//<Description>
// This rule is executed only if a *baseline for comparison* is defined (*diff mode*).
//
// This rule is executed only if some code coverage data is imported
// from some code coverage files.
//
// Often covering 10% of remaining uncovered code of a class, 
// requires as much work as covering the first 90%.
// For this reason, typically teams estimate that 90% coverage is enough.
// However *untestable code* usually means *poorly written code* 
// which usually leads to *error prone code*.
// So it might be worth refactoring and making sure to cover the 10% remaining code
// **because most tricky bugs might come from this small portion of hard-to-test code**.
//
// Not all classes should be 100% covered by tests (like UI code can be hard to test)
// but you should make sure that most of the logic of your application
// is defined in some *easy-to-test classes*, 100% covered by tests.
//
// In this context, this rule warns when a type fully covered by tests is now only partially covered.
//
// Issues of this rule have a **Major** severity because often,
// a type that used to be 100% and is not covered anymore 
// is a bug-prone situation that should be carefully handled.
//</Description>

//<HowToFix>
// Write more unit-tests dedicated to cover code not covered anymore.
// If you find some *hard-to-test code*, it is certainly a sign that this code
// is not *well designed* and hence, needs refactoring.
//
// You'll find code impossible to cover by unit-tests, like calls to *MessageBox.Show()*.
// An infrastructure must be defined to be able to *mock* such code at test-time.
//</HowToFix>]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Types tagged with FullCoveredAttribute should be 100% covered</Name>
warnif count > 0 
from t in Application.Types where
  t.HasAnnotation ("NDepend.Attributes.FullCoveredAttribute".AllowNoMatch()) &&
  t.PercentageCoverage < 100

from m in t .MethodsAndContructors where 
  m.NbLinesOfCode> 0 && 
  m.PercentageCoverage < 100 &&
 !m.IsExcludedFromCoverage

select new { 
   m, 
   m.PercentageCoverage, 
   m.NbLinesOfCodeNotCovered, 
   m.NbLinesOfCode, 

   // Simplistic Debt estimation, because the effort to write tests for a method not 100% tested
   // is already estimated properly with the rule "Code should be tested".
   Debt = m.NbLinesOfCodeNotCovered.Linear(1,2, 10,10).ToMinutes().ToDebt(),

   Severity = Severity.High
}

//<Description>
// This rule lists methods partially covered by tests, of types tagged with
// **FullCoveredAttribute**.
//
// This rule is executed only if some code coverage data is imported
// from some code coverage files.
//
// By using a **FullCoveredAttribute**, you can express in source code the intention
// that a class is 100% covered by tests, and should remain 100% covered in the future.
// If you don't want to link *NDepend.API.dll*, 
// you can use your own attribute and adapt the source code of this rule.
//
// Benefits of using a **FullCoveredAttribute** are twofold:
// Not only the intention is expressed in source code,
// but it is also continuously checked by the present rule.
//
// Often covering 10% of remaining uncovered code of a class, 
// requires as much work as covering the first 90%.
// For this reason, often teams estimate that 90% coverage is enough.
// However *untestable code* usually means *poorly written code* which usually means *error prone code*.
// So it might be worth refactoring and making sure to cover the 10% remaining code
// **because most tricky bugs might come from this small portion of hard-to-test code**.
//
// Not all classes should be 100% covered by tests (like UI code can be hard to test)
// but you should make sure that most of the logic of your application
// is defined in some *easy-to-test classes*, 100% covered by tests.
//
// Issues of this rule have a **Major** severity because often,
// a type that used to be 100% and is not covered anymore 
// is a bug-prone situation that should be carefully handled.
//</Description>

//<HowToFix>
// Write more unit-tests dedicated to cover code of matched classes not covered yet.
// If you find some *hard-to-test code*, it is certainly a sign that this code
// is not *well designed* and hence, needs refactoring.
//</HowToFix>]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Types 100% covered should be tagged with FullCoveredAttribute</Name>
        
warnif count > 0 from t in JustMyCode.Types where
 !t.HasAnnotation ("NDepend.Attributes.FullCoveredAttribute".AllowNoMatch()) &&
  t.PercentageCoverage == 100 &&
 !t.IsGeneratedByCompiler
select new { 
   t,
   t.NbLinesOfCode,
   Debt = 3.ToMinutes().ToDebt(), // It is fast to add such attribute to a type.
   Severity = Severity.Low
}

//<Description>
// This rule is executed only if some code coverage data is imported
// from some code coverage files.
//
// By using a **FullCoveredAttribute**, you can express in source code the intention
// that a class is 100% covered by tests, and should remain 100% covered in the future.
//
// Benefits of using a **FullCoveredAttribute** are twofold:
// Not only the intention is expressed in source code,
// but it is also continuously checked by the present rule.
//
// Issues of this rule have an **Info** severity because they don't reflect
// a problem, but provide an advice for potential improvement.
//</Description>

//<HowToFix>
// Just tag types 100% covered by tests with the **FullCoveredAttribute**
// that can be found in *NDepend.API.dll*,
// or by an attribute of yours defined in your own code 
// (in which case this rule must be adapted).
//</HowToFix>]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Methods should have a low C.R.A.P score</Name>

warnif count > 0
from m in JustMyCode.Methods

// Don't match too short methods
where m.NbLinesOfCode > 10 && m.CoverageDataAvailable

let CC = m.CyclomaticComplexity
let uncov = (100 - m.PercentageCoverage) / 100f
let CRAP = (double)(CC * CC * uncov * uncov * uncov) + CC
where CRAP != null && CRAP > 30
orderby CRAP descending, m.NbLinesOfCode descending
select new { 
   m, 
   CRAP, 
   CC, 
   m.PercentageCoverage, m.NbLinesOfCode,

   // CRAP score equals 30   => 10 minutes debt
   // CRAP score equals 3000 => 3 hours to write tests
   Debt = CRAP.Linear(30,10,  3000, 3*60).ToMinutes().ToDebt(),
   Severity = Severity.High
}

//<Description>
// This rule is executed only if some code coverage data is imported
// from some code coverage files.
//
// So far this rule is disabled because other code coverage rules 
// assess properly code coverage issues.
//
// **Change Risk Analyzer and Predictor** (i.e. CRAP) is a code metric
// that helps in pinpointing overly both complex and untested code.
// Is has been first defined here: 
// http://www.artima.com/weblogs/viewpost.jsp?thread=215899
//
// The Formula is:  **CRAP(m) = CC(m)^2 * (1 – cov(m)/100)^3 + CC(m)**
//
// • where *CC(m)* is the *cyclomatic complexity* of the method *m*
//
// • and *cov(m)* is the *percentage coverage* by tests of the method *m*
//
// Matched methods cumulates two highly *error prone* code smells:
//
// • A complex method, difficult to develop and maintain.
//
// • Non 100% covered code, difficult to refactor without introducing any regression bug.
//
// The higher the CRAP score, the more painful to maintain and error prone is the method.
//
// An arbitrary threshold of 30 is fixed for this code rule as suggested by inventors.
//
// Notice that no amount of testing will keep methods with a Cyclomatic Complexity
// higher than 30, out of CRAP territory.
//
// Notice that this rule doesn't match too short method
// with less than 10 lines of code.
//</Description>

//<HowToFix>
// In such situation, it is recommended to both refactor the complex method logic
// into several smaller and less complex methods 
// (that might belong to some new types especially created),
// and also write unit-tests to full cover the refactored logic. 
//
// You'll find code impossible to cover by unit-tests, like calls to *MessageBox.Show()*.
// An infrastructure must be defined to be able to *mock* such code at test-time.
//</HowToFix>]]></Query>
        <Query Active="False" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Test Methods</Name>

let testAttr = ThirdParty.Types.WithNameIn("TestAttribute", "TestCaseAttribute")
let testMethods = Methods.TaggedWithAnyAttributes(testAttr)
from m in testMethods 
select m

//<Description>
// We advise to not include test Projects in code analyzed by NDepend.
// We estimate that it is acceptable and practical to lower the quality gate of test code,
// because the important measures for tests are:
//
// • The coverage ratio, 
//
// • And the amount of logic results asserted: This includes both
// assertions in test code, and assertions in code covered by tests, 
// like *Code Contract* assertions and *Debug.Assert(…)* assertions.
//
// But if you wish to enforce the quality of test code, you'll need to 
// consider test Projects in your list of application Projects 
// analyzed by NDepend.
//
// In such situation, this code query lists tests methods and you can 
// reuse this code in custom rules.
//</Description>]]></Query>
        <Query Active="False" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Methods directly called by test Methods</Name>

let testAttr = ThirdParty.Types.WithNameIn("TestAttribute", "TestCaseAttribute")
let testMethods = Methods.TaggedWithAnyAttributes(testAttr).ToHashSetEx()

// --- Uncomment this line if your test methods are in dedicated test Projects ---
//let testProjects = testMethods.ParentProjects().ToHashSetEx()

from m in Application.Methods.UsedByAny(testMethods)

// --- Uncomment this line if your test methods are in dedicated test Projects ---
//where !testProjects.Contains(m.ParentProject)

select new { m , 
             calledByTests = m.MethodsCallingMe.Intersect(testMethods ),
             // --- Uncomment this line if your project import some coverage data ---
             // m.PercentageCoverage 
}


//<Description>
// This query lists all methods directly called by tests methods.
// Overrides of virtual and abstract methods, called through polymorphism, are not listed.
// Methods solely invoked through a delegate are not listed.
// Methods solely invoked through reflection are not listed.
//
// We advise to not include test Projects in code analyzed by NDepend.
// We estimate that it is acceptable and practical to lower the quality gate of test code,
// because the important measures for tests are:
//
// • The coverage ratio, 
//
// • And the amount of logic results asserted: This includes both
// assertions in test code, and assertions in code covered by tests, 
// like *Code Contract* assertions and *Debug.Assert(…)* assertions.
//
// But if you wish to run this code query,
// you'll need to consider test Projects in your list of 
// application Projects analyzed by NDepend.
//</Description>]]></Query>
        <Query Active="False" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Methods directly and indirectly called by test Methods</Name>

let testAttr = from t in ThirdParty.Types.WithNameIn("TestAttribute", "TestCaseAttribute") select t
let testMethods = Methods.TaggedWithAnyAttributes(testAttr)

// --- Uncomment this line if your test methods are in dedicated test Projects ---
// let testProjects = testMethods.ParentProjects().ToHashSetEx()

let depthOfCalledByTest = Application.Methods.DepthOfIsUsedByAny(testMethods)
from pair in depthOfCalledByTest
where pair.Value > 0 
orderby pair.Value ascending
// --- Uncomment this line if your test methods are in dedicated test Projects ---
//&& !testProjects.Contains(pair.CodeElement.ParentProject)

select new { 
  method = pair.CodeElement, 
  // (depthOfCalledByTests == 1) means that the method is directly called by tests
  // (depthOfCalledByTests == 2) means that the method is directly called by a method directly called by tests
  // …
  depthOfCalledByTests = pair.Value,
  nbLinesOfCode = pair.CodeElement.NbLinesOfCode,
  // --- Uncomment this line if your project import some coverage data ---
  // m.PercentageCoverage
}

//<Description>
// This query lists all methods *directly or indirectly* called by tests methods.
// *Indirectly* called by a test means that a test method calls a method, that calls a method…
// From this recursion, a code metric named *depthOfCalledByTests* is inferred,
// The value *1* means directly called by test,
// the value *2* means called by a method that is called by a test…
//
// Overrides of virtual and abstract methods, called through polymorphism, are not listed.
// Methods solely invoked through a delegate are not listed.
// Methods solely invoked through reflection are not listed.
//
// We advise to not include test Projects in code analyzed by NDepend.
// We estimate that it is acceptable and practical to lower the quality gate of test code,
// because the important measures for tests are:
//
// • The coverage ratio, 
//
// • And the amount of logic results asserted: This includes both
// assertions in test code, and assertions in code covered by tests, 
// like *Code Contract* assertions and *Debug.Assert(…)* assertions.
//
// But if you wish to run this code query,
// you'll need to consider test Projects in your list of 
// application Projects analyzed by NDepend.
//</Description>]]></Query>
      </Group>
      <Group Name="Dead Code" Active="True" ShownInReport="True">
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Avoid unused private fields.</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="UnusedPrivateField" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 10.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Avoid unused local variables.</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="UnusedLocalVariable" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 10.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Avoid unused private methods.</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="UnusedPrivateMethod" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 10.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Avoid unused parameters.</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="UnusedFormalParameter" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 10.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Avoid modifiers which are implied by the context</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="UnusedModifier" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 10.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
      </Group>
      <Group Name="Controversial" Active="True" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Avoid unnecessary constructors - the compiler will generate these for you</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="UnnecessaryConstructor" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 1.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Assigning an Object to null is a code smell.  Consider refactoring.</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="NullAssignment" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 2.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>A method should have only one exit point, and that should be the last statement in the method</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="OnlyOneReturn" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 10.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Avoid assignments in operands</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="AssignmentInOperand" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 10.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Each class should declare at least one constructor</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="AtLeastOneConstructor" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 1.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Avoid importing anything from the sun.* packages</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="DontImportSun" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 2.ToMinutes().ToDebt(),
                          Severity =Severity.Low
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Suspicious decimal characters following octal escape in string literal</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="SuspiciousOctalEscape" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 10.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>It is a good practice to call super() in a constructor</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="CallSuperInConstructor" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 1.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>This statement may have some unnecessary parentheses</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="UnnecessaryParentheses" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 5.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Use explicit scoping instead of the default package private level</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="DefaultPackage" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 10.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Avoid using final local variables, turn them into fields</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="AvoidFinalLocalVariable" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 5.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Do not use the short type</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="AvoidUsingShortType" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 2.ToMinutes().ToDebt(),
                          Severity =Severity.Low
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Use of modifier volatile is not recommended.</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="AvoidUsingVolatile" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 2.ToMinutes().ToDebt(),
                          Severity =Severity.Low
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>The use of native code is not recommended.</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="AvoidUsingNativeCode" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 2.ToMinutes().ToDebt(),
                          Severity =Severity.Low
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>You should modify visibility of class or methods using getDeclaredConstructors(), getDeclaredConstructor(Class[]), setAccessible() or PrivilegedAction.</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="AvoidAccessibilityAlteration" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 5.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Do not explicitly trigger a garbage collection.</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="DoNotCallGarbageCollectionExplicitly" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 2.ToMinutes().ToDebt(),
                          Severity =Severity.Low
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Use one line for each declaration, it enhances code readability.</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="OneDeclarationPerLine" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 2.ToMinutes().ToDebt(),
                          Severity =Severity.Low
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Avoid prefixing parameters by in, out or inOut. Uses Javadoc to document this behavior.</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="AvoidPrefixingMethodParameters" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 2.ToMinutes().ToDebt(),
                          Severity =Severity.Low
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Avoid using Literals in Conditional Statements</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="AvoidLiteralsInIfCondition" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 5.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Rather than using a lot of String arguments, consider using a container object for those values.</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="UseObjectForClearerAPI" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 10.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>If you run in Java5 or newer and have concurrent access, you should use the ConcurrentHashMap implementation</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="UseConcurrentHashMap" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 10.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
      </Group>
      <Group Name="Empty Code" Active="True" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Avoid empty catch blocks</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="EmptyCatchBlock" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 10.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Avoid empty if statements</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="EmptyIfStmt" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 2.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Avoid empty while statements</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="EmptyWhileStmt" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 2.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Avoid empty try blocks</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="EmptyTryBlock" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 2.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Avoid empty finally blocks</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="EmptyFinallyBlock" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 10.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Avoid empty switch statements</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="EmptySwitchStatements" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 2.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Avoid empty synchronized blocks</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="EmptySynchronizedBlock" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 10.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>An empty statement (semicolon) not part of a loop</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="EmptyStatementNotInLoop" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 10.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Empty initializer was found</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="EmptyInitializer" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 2.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Avoid empty block statements.</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="EmptyStatementBlock" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 1.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Empty static initializer was found</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="EmptyStaticInitializer" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 10.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
      </Group>
      <Group Name="Unnecessary Code" Active="True" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Avoid unnecessary temporaries when converting primitives to Strings</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="UnnecessaryConversionTemporary" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 10.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Avoid unnecessary return statements</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="UnnecessaryReturn" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 2.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Unnecessary final modifier in final class</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="UnnecessaryFinalModifier" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 2.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Overriding method merely calls super</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="UselessOverridingMethod" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 2.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>An operation on an Immutable object (String, BigDecimal or BigInteger) wont change the object itself</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="UselessOperationOnImmutable" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 10.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Invoke equals() on the object youve already ensured is not null</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="UnusedNullCheckInEquals" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 2.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Useless parentheses.</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="UselessParentheses" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 2.ToMinutes().ToDebt(),
                          Severity =Severity.Low
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Useless qualified this usage in the same class.</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="UselessQualifiedThis" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 1.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
      </Group>
      <Group Name="Logging" Active="True" ShownInReport="False">
        <Group Name="Jakarta Commons Logging" Active="True" ShownInReport="False">
          <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Use the correct logging statement for logging exceptions</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="UseCorrectExceptionLogging" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 10.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
          <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Logger should be defined private static final and have the correct class</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="ProperLogger" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 2.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
          <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>debug logging that involves string concatenation should be guarded with isDebugEnabled() checks</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="GuardDebugLogging" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 10.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
          <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>There is log block not surrounded by if</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="GuardLogStatement" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 2.ToMinutes().ToDebt(),
                          Severity =Severity.Low
                       }

                ]]></Query>
        </Group>
        <Group Name="Java Logging" Active="True" ShownInReport="False">
          <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Class contains more than one logger.</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="MoreThanOneLogger" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 2.ToMinutes().ToDebt(),
                          Severity =Severity.Low
                       }

                ]]></Query>
          <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>The Logger variable declaration does not contain the static and final modifiers</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="LoggerIsNotStaticFinal" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 2.ToMinutes().ToDebt(),
                          Severity =Severity.Low
                       }

                ]]></Query>
          <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Avoid printStackTrace(); use a logger call instead.</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="AvoidPrintStackTrace" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 5.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
          <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Log block not surrounded by if</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="GuardLogStatementJavaUtil" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 2.ToMinutes().ToDebt(),
                          Severity =Severity.Low
                       }

                ]]></Query>
          <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Invalid message format</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="InvalidSlf4jMessageFormat" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 2.ToMinutes().ToDebt(),
                          Severity =Severity.Low
                       }

                ]]></Query>
        </Group>
      </Group>
      <Group Name="Basic" Active="True" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Avoid modifying an outer loop incrementer in an inner loop for update expression</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="JumbledIncrementer" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 10.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>This for loop could be simplified to a while loop</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="ForLoopShouldBeWhileLoop" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 10.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Ensure you override both equals() and hashCode()</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="OverrideBothEqualsAndHashcode" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 10.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Double checked locking is not thread safe in Java.</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="DoubleCheckedLocking" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 2.ToMinutes().ToDebt(),
                          Severity =Severity.Low
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Avoid returning from a finally block</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="ReturnFromFinallyBlock" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 10.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Do not use if statements that are always true or always false</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="UnconditionalIfStatement" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 10.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Avoid instantiating Boolean objects; reference Boolean.TRUE or Boolean.FALSE or call Boolean.valueOf() instead.</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="BooleanInstantiation" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 2.ToMinutes().ToDebt(),
                          Severity =Severity.Low
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>These nested if statements could be combined</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="CollapsibleIfStatements" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 10.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>This usage of the Collection.toArray() method will throw a ClassCastException.</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="ClassCastExceptionWithToArray" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 10.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Avoid creating BigDecimal with a decimal (float/double) literal. Use a String literal</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="AvoidDecimalLiteralsInBigDecimalConstructor" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 10.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>The null check here is misplaced; if the variable is null there will be a NullPointerException</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="MisplacedNullCheck" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 10.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Avoid using java.lang.ThreadGroup; it is not thread safe</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="AvoidThreadGroup" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 10.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Method call on object which may be null</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="BrokenNullCheck" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 2.ToMinutes().ToDebt(),
                          Severity =Severity.Low
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Dont create instances of already existing BigInteger and BigDecimal (ZERO, ONE, TEN)</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="BigIntegerInstantiation" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 10.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Do not start a literal by 0 unless its an octal value</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="AvoidUsingOctalValues" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 10.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Do not hard code the IP address ${variableName}</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="AvoidUsingHardCodedIP" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 10.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Always check the return of one of the navigation method (next,previous,first,last) of a ResultSet.</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="CheckResultSet" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 10.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Using multiple unary operators may be a bug, and/or is confusing.</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="AvoidMultipleUnaryOperators" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 2.ToMinutes().ToDebt(),
                          Severity =Severity.Low
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>No need to explicitly extend Object.</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="ExtendsObject" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 2.ToMinutes().ToDebt(),
                          Severity =Severity.Low
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Check the value returned by the skip() method of an InputStream to see if the requested number of bytes has been skipped.</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="CheckSkipResult" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 10.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Avoid using a branching statement as the last in a loop.</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="AvoidBranchingStatementAsLastInLoop" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 2.ToMinutes().ToDebt(),
                          Severity =Severity.Low
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Dont call Thread.run() explicitly, use Thread.start()</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="DontCallThreadRun" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 2.ToMinutes().ToDebt(),
                          Severity =Severity.Low
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Dont use floating point for loop indices. If you must use floating point, use double.</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="DontUseFloatTypeForLoopIndices" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 10.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Ternary operators that can be simplified with || or &&</Name>
                warnif count > 0 from issue in ImportedIssues where issue.ToolName=="Pmd" && issue.Type=="SimplifiedTernary" select new { issue, issue.FilePath, Line = issue.BeginLine ,
                          Debt = 10.ToMinutes().ToDebt(),
                          Severity =Severity.High
                       }

                ]]></Query>
      </Group>
    </Group>
    <Group Name="Naming Conventions" Active="True" ShownInReport="False">
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Instance fields should begin with a lower character </Name>
warnif count > 0 from f in Application.Fields where 
  !f.NameLike (@"^[a-z]")  && 
  !f.IsStatic && 
  !f.IsLiteral && 
  !f.IsGeneratedByCompiler 
select new { f, f.SizeOfInst,
   Debt = 3.ToMinutes().ToDebt(),
   Severity = Severity.Medium} 

// This naming convention provokes debate.
// Don't hesitate to customize the regex of 
// NameLike to your preference.]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Interface name should begin with an Upper character</Name>
warnif count > 0 from t in Application.Types where 
t.IsInterface  &&
!t.SimpleNameLike (@"^[A-Z]")
select new {t,
   Debt = 3.ToMinutes().ToDebt(),
   Severity = Severity.Medium}
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Exception class name should be suffixed with 'Exception'</Name>
warnif count > 0 from t in Application.Types where 
  t.IsExceptionClass && 
  !t.NameLike (@"Exception$")
select new { t, t.NbLinesOfCode,
   Debt = 3.ToMinutes().ToDebt(),
   Severity = Severity.Medium}

// The name of an exception class should end with 'Exception'.]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Types name should begin with an Upper character</Name>
warnif count > 0 from t in JustMyCode.Types where 
  // The name of a type should begin with an Upper letter.
  !t.SimpleNameLike (@"^[A-Z]") &&     

  // Except if it is generated by compiler or ...
  
  !t.IsGeneratedByCompiler


select new { t, t.NbLinesOfCode,
   Debt = 3.ToMinutes().ToDebt(),
   Severity = Severity.Medium}]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Methods name should begin with an lower character</Name>
warnif count > 0 from m in JustMyCode.Methods where 
  !m.NameLike (@"^[a-z]") && 
  
  !m.IsGeneratedByCompiler && !m.IsConstructor
select new {m,
   Debt = 3.ToMinutes().ToDebt(),
   Severity = Severity.Medium}

// The name of a regular method should 
// begin with an Upper letter.]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Avoid types with name too long</Name>
warnif count > 0 from t in Application.Types 
where !t.IsGeneratedByCompiler

where t.SimpleName.Length > 35 
select new { t, t.SimpleName ,
   Debt = 3.ToMinutes().ToDebt(),
   Severity = Severity.Medium}

      ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Avoid methods with name too long</Name>
warnif count > 0 from m in Application.Methods where 
  !m.IsGeneratedByCompiler &&
 m.SimpleName.Length > 35

select new { m, m.SimpleName ,
   Debt = 3.ToMinutes().ToDebt(),
   Severity = Severity.Medium}

// The regex matches methods with name longer 
// than 35 characters.
// Method Name doesn't contain the type and package 
// prefix, FullName does.
// The regex computes the method name length from 
// the beginning until the first open parenthesis 
// or first lower than (for generic methods).
// Explicit Interface Implementation methods are 
// discarded because their names are prefixed 
// with the interface name.
      ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Avoid fields with name too long</Name>
warnif count > 0 from f in Application.Fields where
 !f.IsGeneratedByCompiler &&
  f.Name.Length > 35
select new {f,
   Debt = 3.ToMinutes().ToDebt(),
   Severity = Severity.Medium}

// The regex matches fields with name longer 
// than 35 characters.
// Field Name doesn't contain the type and 
// package prefix, FullName does.
      ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[ // <Name>Avoid having different types with same name</Name>
// Such practice typically creates confusion, 
// and type naming collision inside a source file.

warnif count > 0

// This rule matches also collisions between 
// application and third-party types sharing a same name.
let groups = JustMyCode.Types.Union(ThirdParty.Types)
                 // Discard nested types, whose name is 
                 // prefixed with the parent type name.
                 .Where(t => !t.IsNested)
                 
                 // Group types by name.
                 .GroupBy(t => t.Name)

from @group in groups 
   where @group.Count() > 1

   // Let's see if types with the same name are declared
   // in different packages.
   // (t.FullName is {packageName}.{typeName} )
   let groupsFullName = @group.GroupBy(t => t.FullName)
   where groupsFullName.Count() > 1

   // If several types with same name are declared in different packages
   // eliminate the case where all types are declared in third-party projects.
   let types= groupsFullName.SelectMany(g => g)
   where types.Any(t => !t.IsThirdParty)
        // Uncomment this line, to only gets naming collision involving
        // both application adn third-party types.
        //         && types.Any(t => t.IsThirdParty)

orderby types.Count() descending 

select new { t = types.First(),
             // In the 'types' column, make sure to group matched types 
             // by parent projects and parent packages.
             types,
   Debt = 3.ToMinutes().ToDebt(),
   Severity = Severity.Medium}
            ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Avoid prefixing type name with parent package name</Name>

// For example a type named "RuntimeEnvironment"
// declared in a package named "Foo.Runtime"
// should be named "Environment"

from n in Application.Packages where n.Name.Length > 0
from t in n.ChildTypes
where 
 !t.IsGeneratedByCompiler &&
 !t.IsNested &&
  t.Name.IndexOf(n.SimpleName) == 0
select new { t, packageName = n.SimpleName,
   Debt = 3.ToMinutes().ToDebt(),
   Severity = Severity.Medium}]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Avoid naming types and packages with the same identifier</Name>

// Not only this can provoke compiler resolution collision,
// but also, this makes code less maintainable because
// concepts are not concisely identified.

warnif count > 0
let hashsetShortNames = Packages.Where(n => n.Name.Length > 0).Select(n => n.SimpleName).ToHashSetEx()

from t in JustMyCode.Types
where hashsetShortNames.Contains(t.Name)
select new { t, packages = Packages.Where(n => n.SimpleName == t.Name) ,
   Debt = 3.ToMinutes().ToDebt(),
   Severity = Severity.Medium}]]></Query>
    </Group>
    <Group Name="Trend Metrics" Active="True" ShownInReport="False">
      <Group Name="Issues" Active="True" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# New Issues since Baseline" Unit="issues"/>
from issue in Issues 
where issue.WasAdded()
select new { issue, issue.Debt, issue.AnnualInterest, issue.Severity }]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Issues Fixed since Baseline" Unit="issues"/>
from issue in Issues 
where issue.WasFixed()
select new { issue, issue.Debt, issue.AnnualInterest, issue.Severity }]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Issues Worsened since Baseline" Unit="issues"/>
from issue in Issues 
where !issue.WasAdded() && 
      (issue.DebtDiff() > Debt.Zero || issue.AnnualInterestDiff() > AnnualInterest.Zero)
select new { 
   issue, 
   issue.Debt, debtDiff = issue.DebtDiff(), 
   issue.AnnualInterest, annualInterestDiff = issue.AnnualInterestDiff(),
   issue.Severity 
}

//<Description>
// An issue is considered worsened if its *debt* increased since the baseline.
//
// Debt documentation: http://www.jarchitect.com/Doc_TechnicalDebtt#Debt
//</Description>
]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Blocker Issues" Unit="issues"/>
from issue in Issues 
where issue.Severity == Severity.Blocker
select new { issue, issue.Debt, issue.AnnualInterest, issue.Severity }

//<Description>
// An issue with the severity **Blocker** cannot move to production, it must be fixed.
//
// The severity of an issue is inferred from the issue *annual interest*
// and thresholds defined in the NDepend Project Properties > Issue and Debt.
//</Description>]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Critical Issues" Unit="issues"/>
from issue in Issues 
where issue.Severity == Severity.Critical
select new { issue, issue.Debt, issue.AnnualInterest, issue.Severity }

//<Description>
// An issue with a severity level **Critical** shouldn't move to production. 
// It still can for business imperative needs purposes, but at worth it must be fixed during the next iterations. 
//
// The severity of an issue is inferred from the issue *annual interest*
// and thresholds defined in the NDepend Project Properties > Issue and Debt.
//</Description>]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Major Issues" Unit="issues"/>
from issue in Issues 
where issue.Severity == Severity.High
select new { issue, issue.Debt, issue.AnnualInterest, issue.Severity }

//<Description>
// An issue with a severity level **Major** should be fixed quickly, but can wait until the next scheduled interval.
//
// The severity of an issue is inferred from the issue *annual interest*
// and thresholds defined in the NDepend Project Properties > issue and Debt.
//</Description>]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Minor Issues" Unit="issues"/>
from issue in Issues 
where issue.Severity == Severity.Medium
select new { issue, issue.Debt, issue.AnnualInterest, issue.Severity }

//<Description>
// An issue with a severity level **Minor** is a warning that if not fixed, won't have a significant impact on development.
//
// The severity of an issue is inferred from the issue *annual interest*
// and thresholds defined in the NDepend Project Properties > issue and Debt.
//</Description>]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Info Issues" Unit="issues"/>
from issue in Issues 
where issue.Severity == Severity.Low
select new { issue, issue.Debt, issue.AnnualInterest, issue.Severity }

//<Description>
// The severity level **Info** is used by issues that have a zero, or close to zero, 
// value for **Annual Interest**.
//
// Issues with a **Info** or **Minor** severity level represents small improvements, 
// ways to make the code looks more elegant.
//
// The **Broken Window Theory** https://en.wikipedia.org/wiki/Broken_windows_theory states that:
//
// *"Consider a building with a few broken windows. 
// If the windows are not repaired, the tendency is for vandals to break a few more windows. 
// Eventually, they may even break into the building, and if it's unoccupied, perhaps become 
// squatters or light fires inside."*
//

// Issues with a *Info* or *Minor* severity level represents the *broken windows* of a code base.
// If they are not fixed, the tendency is for developers to not care for living 
// in an elegant code, which will result in extra-maintenance-cost in the long term.
//
// The severity of an issue is inferred from the issue *annual interest*
// and thresholds defined in the NDepend Project Properties > issue and Debt.
//</Description>]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Blocker/Critical/Major Issues" Unit="issues"/>
from issue in Issues 
where issue.Severity.EqualsAny(Severity.Blocker, Severity.Critical, Severity.High)
select new { issue, issue.Debt, issue.AnnualInterest, issue.Severity }

//<Description>
// The number of issues with a severity Blocker, Critical or Major.
//
// An issue with the severity **Blocker** cannot move to production, it must be fixed.
//
// An issue with a severity level **Critical** shouldn't move to production. 
// It still can for business imperative needs purposes, but at worth it must be fixed during the next iterations. 
//
// An issue with a severity level **Major** should be fixed quickly, but can wait until the next scheduled interval.
//</Description>]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Issues" Unit="issues"/>
from issue in Issues 
select new { issue, issue.Debt, issue.AnnualInterest, issue.Severity }

//<Description>
// The number of issues no matter the issue severity.
//</Description>]]></Query>
      </Group>
      <Group Name="Rules" Active="True" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Rules" Unit="rules"/>
from rule in Rules
select new { 
   rule, 
   issues = rule.Issues(), 
   debt = rule.Debt(), 
   annualInterest = rule.AnnualInterest(),
   maxSeverity = rule.IsViolated() ? (Severity?)rule.Issues().Max(i => i.Severity) : null
}

//<Description>
// This trend metric counts the number of active rules.
// This count includes violated and not violated rules.
// This count includes critical and non critical rules.
//
// When no baseline is available, rules that rely on diff are not counted.
// If you observe that this count slightly decreases with no apparent reason,
// the reason is certainly that rules that rely on diff are not counted
// because the baseline is not defined.
//</Description>]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Rules Violated" Unit="rules"/>
from rule in Rules
where rule.IsViolated()
select new { 
   rule, 
   issues = rule.Issues(), 
   debt = rule.Debt(), 
   annualInterest = rule.AnnualInterest(),
   maxSeverity = rule.Issues().Max(i => i.Severity)
}

//<Description>
// This trend metric counts the number of active rules that are violated.
// This count includes critical and non critical rules.
//
// When no baseline is available, rules that rely on diff are not counted.
// If you observe that this count slightly decreases with no apparent reason,
// the reason is certainly that rules that rely on diff are not counted
// because the baseline is not defined.
//</Description>]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Critical Rules Violated" Unit="rules"/>
from rule in Rules
where rule.IsViolated() && rule.IsCritical
select new { 
   rule, 
   issues = rule.Issues(), 
   debt = rule.Debt(), 
   annualInterest = rule.AnnualInterest(),
   maxSeverity = rule.Issues().Max(i => i.Severity)
}

//<Description>
// This trend metric counts the number of critical active rules that are violated.
//
// The concept of critical rule is useful to pinpoint certain rules that should not be violated.
//
// When no baseline is available, rules that rely on diff are not counted.
// If you observe that this count slightly decreases with no apparent reason,
// the reason is certainly that rules that rely on diff are not counted
// because the baseline is not defined.
//</Description>]]></Query>
      </Group>
      <Group Name="Quality Gates" Active="True" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Quality Gates" Unit="quality gates"/>
from qualityGate in QualityGates
select new { 
   qualityGate , 
   qualityGate.ValueString,
   qualityGate.Status, 
}

//<Description>
// This trend metric counts the number of active quality gates,
// no matter the gate status (Pass, Warn, Fail).
//
// When no baseline is available, quality gates that rely on diff are not counted.
// If you observe that this count slightly decreases with no apparent reason,
// the reason is certainly that quality gates that rely on diff are not counted
// because the baseline is not defined.
//</Description>]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Quality Gates Warn" Unit="quality gates"/>
from qualityGate in QualityGates
where qualityGate.Warn
select new { 
   qualityGate , 
   qualityGate.ValueString, 
}

//<Description>
// This trend metric counts the number of active quality gates that warns.
//
// When no baseline is available, quality gates that rely on diff are not counted.
// If you observe that this count slightly decreases with no apparent reason,
// the reason is certainly that quality gates that rely on diff are not counted
// because the baseline is not defined.
//</Description>]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Quality Gates Fail" Unit="quality gates"/>
from qualityGate in QualityGates
where qualityGate.Fail
select new { 
   qualityGate , 
   qualityGate.ValueString, 
}

//<Description>
// This trend metric counts the number of active quality gates that fails.
//
// When no baseline is available, quality gates that rely on diff are not counted.
// If you observe that this count slightly decreases with no apparent reason,
// the reason is certainly that quality gates that rely on diff are not counted
// because the baseline is not defined.
//</Description>]]></Query>
      </Group>
      <Group Name="Debt" Active="True" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Percentage Debt" Unit="%" />
let timeToDev = codeBase.EffortToDevelop()
let debt = Issues.Sum(i => i.Debt)
select 100d * debt.ToManDay() / timeToDev.ToManDay()

// <Description>
// Infer a percentage from:
//
// • the estimated total time to develop the code base
//
// • and the the estimated total time to fix all issues (the Debt).
//
// Estimated total time to develop the code base is inferred from 
// # lines of code of the code base and from the 
// *Estimated number of man-dat to develop 1000 logicial lines of code*
// setting found in NDepend Project Properties > Issue and Debt.
//
// Debt documentation: http://www.jarchitect.com/Doc_TechnicalDebtt#Debt
// </Description>]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Debt" Unit="man-days" />
Issues.Sum(i => i.Debt).ToManDay()

//<Description>
// Debt documentation: http://www.jarchitect.com/Doc_TechnicalDebtt#Debt
//</Description>]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="New Debt since Baseline" Unit="man-days" />
let debt = Issues.Sum(i => i.Debt)
let debtInBaseline = IssuesInBaseline.Sum(i => i.Debt)
select (debt - debtInBaseline).ToManDay()

//<Description>
// Debt added (or fixed if negative) since baseline.
//
// Debt documentation: http://www.jarchitect.com/Doc_TechnicalDebtt#Debt
//</Description>]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Annual Interest" Unit="man-days" />
Issues.Sum(i => i.AnnualInterest).ToManDay()

//<Description>
// Annual Interest documentation: http://www.jarchitect.com/Doc_TechnicalDebtt#AnnualInterest
//</Description>]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="New Annual Interest since Baseline" Unit="man-days" />
let ai = Issues.Sum(i => i.AnnualInterest)
let aiInBaseline = IssuesInBaseline.Sum(i => i.AnnualInterest)
select (ai - aiInBaseline).ToManDay()

//<Description>
// Annual Interest added (or fixed if negative) since baseline.
//
// Annual Interest documentation: http://www.jarchitect.com/Doc_TechnicalDebtt#AnnualInterest
//</Description>]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Breaking Point" Unit="years"/>
(Issues.Sum(i =>i.Debt).BreakingPoint(Issues.Sum(i =>i.AnnualInterest))).TotalYears()

// <Description>
// The **breaking point** of a set of issues is the **debt** divided by the **annual interest**.
//
// The *debt* is the estimated cost-to-fix the issues.
//
// The *annual interest* is the estimated cost-to-**not**-fix the issues, per year.
//
// Hence the *breaking point* is the point in time from now, when not fixing the issues cost as much as fixing the issue.
//
// Breaking Point documentation: http://www.jarchitect.com/Doc_TechnicalDebtt#BreakingPoint
// </Description>]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Breaking Point of Blocker / Critical / Major Issues" Unit="years"/>
let issues = Issues.Where(i => i.Severity.EqualsAny(Severity.Blocker, Severity.Critical, Severity.High))
select (issues.Sum(i =>i.Debt).BreakingPoint(issues.Sum(i =>i.AnnualInterest))).TotalYears()

// <Description>
// The **breaking point** of a set of issues is the **debt** divided by the **annual interest**.
//
// The *debt* is the estimated cost-to-fix the issues.
//
// The *annual interest* is the estimated cost-to-**not**-fix the issues, per year.
//
// Hence the *breaking point* is the point in time from now, when not fixing the issues cost as much as fixing the issue.
//
// Breaking Point documentation: http://www.jarchitect.com/Doc_TechnicalDebtt#BreakingPoint
// </Description>]]></Query>
      </Group>
      <Group Name="Code Size" Active="True" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Lines of Code" Unit="LoC" />
codeBase.NbLinesOfCode]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Lines of Code (JustMyCode)" Unit="LoC" />
JustMyCode.Methods.Sum(m => m.NbLinesOfCode)

// JustMyCode is defined by code queries prefixed with 'notmycode' 
// in the group 'Defining JustMyCode'.
]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Lines of Code (NotMyCode)" Unit="LoC" />
Application.Methods.Except(JustMyCode.Methods).Sum(m => m.NbLinesOfCode)

// JustMyCode is defined by code queries prefixed with 'notmycode' 
// in the group 'Defining JustMyCode'.
]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Lines of Code Added since the Baseline" Unit="LoC" />  
from a in Application.Projects
let nbLocAdded = !a.IsPresentInBothBuilds()
                 ? a.NbLinesOfCode
                 : (a.NbLinesOfCode != null && a.OlderVersion().NbLinesOfCode != null)
               ? a.NbLinesOfCode - (int)a.OlderVersion().NbLinesOfCode 
                   : 0
select (double?)nbLocAdded


// A value is computed by this Trend Metric query
// only if a Baseline for Comparison is provided.
// See Project Properties > Analysis > Baseline for Comparison
]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Source Files" Unit="Source Files" />
Application.Projects.SelectMany(
  a => a.SourceDecls.Select(sd => sd.SourceFile.FilePathString.ToLower()))
.Distinct()
.Count()

//<Description>
// This trend metric counts the number of source files.
//
// If a value 0 is obtained, it means that at analysis time,
// Projects PDB files were not available.
// http://www.jarchitect.com/docs/jarchitect-analysis-inputs-explanation
//
// So far source files cannot be matched by a code query.
// However editing the query "Application Types" and then
// *Group by source file declarations* will list source files
// with types source declarations.
//</Description>]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# IL Instructions" Unit="IL Instructions" />
codeBase.NbBCInstructions
]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# IL Instructions (NotMyCode)" Unit="IL Instructions" />
Application.Methods.Except(JustMyCode.Methods).Sum(m => m.NbBCInstructions)

// JustMyCode is defined by code queries prefixed with 'notmycode' 
// in the group 'Defining JustMyCode'.
]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Lines of Comments" Unit="Lines" />  
codeBase.NbLinesOfComment

//<Description>
// This trend metric returns the number of lines of comment
// counted in application source files.
//
// So far commenting information is only extracted from C# source code
// and VBJava support is planned.
//</Description>]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Percentage of Comments" Unit="%" />  
codeBase.PercentageComment

//<Description>
// This trend metric returns the percentage of comment
// compared to the number of **logical**lines of code.
//
// So far commenting information is only extracted from C# source code
// and VBJava support is planned.
//</Description>]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Projects" Unit="Projects" />
from a in Application.Projects
select new {
   a,
   Debt = a.AllDebt(),
   Issues = a.AllIssues()
}

//<Description>
// This trend metric query counts all application Projects.
// For each project it shows the estimated **all** technical-debt and **all** issues.
// **All** means debt and issues of the project and of its child packages, types and members.
//</Description>]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Packages" Unit="Packages" />
from n in Application.Packages
select new {
   n,
   Debt = n.AllDebt(),
   Issues = n.AllIssues()
}

//<Description>
// This trend metric query counts all application packages.
// For each package it shows the estimated **all** technical-debt and **all** issues.
// **All** means debt and issues of the package and of its child types and members.
//</Description>]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Types" Unit="Types" />
from t in Application.Types.Where(t => !t.IsGeneratedByCompiler)
select new {
   t,
   Debt = t.AllDebt(),
   Issues = t.AllIssues()
}

//<Description>
// This trend metric query counts all application types non-generated by compiler.
// For each type it shows the estimated **all** technical-debt and **all** issues.
// **All** means debt and issues of the type and of its child members.
//</Description>]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Public Types" Unit="Types" />
Application.Types.Where(t => t.IsPubliclyVisible && !t.IsGeneratedByCompiler)]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Classes" Unit="Types" />
Application.Types.Where(t => t.IsClass && !t.IsGeneratedByCompiler)]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Abstract Classes" Unit="Types" />
Application.Types.Where(t => t.IsClass && t.IsAbstract && !t.IsGeneratedByCompiler)]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Interfaces" Unit="Types" />
Application.Types.Where(t => t.IsInterface)]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Methods" Unit="Methods" />
from m in Application.Methods.Where(m => !m.IsGeneratedByCompiler)
select new {
   m,
   Debt = m.Debt(),
   Issues = m.Issues()
}

//<Description>
// This trend metric query counts all application methods non-generated by compiler.
// For each method it shows the estimated technical-debt and the issues.
//</Description>]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Abstract Methods" Unit="Methods" />
Application.Methods.Where(m => m.IsAbstract)]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Concrete Methods" Unit="Methods" />
Application.Methods.Where(m => !m.IsAbstract && !m.IsGeneratedByCompiler)]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Fields" Unit="Fields" />
from f in Application.Fields.Where(f => 
   !f.IsEnumValue && 
   !f.ParentType.IsEnumeration &&
   !f.IsGeneratedByCompiler && 
   !f.IsLiteral)
select new {
   f,
   Debt = f.AllDebt(),
   Issues = f.AllIssues()
}

//<Description>
// This trend metric query counts all application fields non-generated by compiler
// that are not enumeration values nor constant values.
// For each field it shows the estimated technical-debt and the issues.
//</Description>]]></Query>
      </Group>
      <Group Name="Maximum and Average" Active="True" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Max # Lines of Code for Methods (JustMyCode)" Unit="LoC" />
JustMyCode.Methods
          .Max(m => m.NbLinesOfCode)

// Here is the code query to get the (JustMyCode) method with largest # Lines of Code
// JustMyCode.Methods.OrderByDescending(m => m.NbLinesOfCode).Take(1).Select(m => new {m, m.NbLinesOfCode})]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Average # Lines of Code for Methods" Unit="LoC" />
Application.Methods.Where(m => m.NbLinesOfCode > 0)
                   .Average(m => m.NbLinesOfCode)]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Average # Lines of Code for Methods with at least 3 Lines of Code" Unit="LoC" />
Application.Methods.Where(m => m.NbLinesOfCode >= 3)
                   .Average(m => m.NbLinesOfCode)]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Max # Lines of Code for Types (JustMyCode)" Unit="LoC" />
JustMyCode.Types
          .Max(t => t.NbLinesOfCode)

// Here is the code query to get the (JustMyCode) type with largest # Lines of Code
// JustMyCode.Types.OrderByDescending(t => t.NbLinesOfCode).Take(1).Select(t => new {t, t.NbLinesOfCode})]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Average # Lines of Code for Types" Unit="LoC" />
Application.Types.Where(t => t.NbLinesOfCode > 0)
                 .Average(t => t.NbLinesOfCode)]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Max Cyclomatic Complexity for Methods" Unit="Paths" />
Application.Methods
           .Max(m => m.CyclomaticComplexity)

// Here is the code query to get the most complex method, according to Cyclomatic Complexity
// Application.Methods.OrderByDescending(m => m.CyclomaticComplexity).Take(1).Select(m => new {m, m.CyclomaticComplexity})]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Average Cyclomatic Complexity for Methods" Unit="Paths" />
Application.Methods.Where(m => m.NbLinesOfCode> 0)
                   .Average(m => m.CyclomaticComplexity)]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Max IL Cyclomatic Complexity for Methods" Unit="Paths" />
Application.Methods
           .Max(m => m.BCCyclomaticComplexity)

// Here is the code query to get the most complex method, according to Cyclomatic Complexity computed from IL code.
// Application.Methods.OrderByDescending(m => m.BCCyclomaticComplexity).Take(1).Select(m => new {m, m.CyclomaticComplexity})]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Average IL Cyclomatic Complexity for Methods" Unit="Paths" />
Application.Methods.Where(m => m.NbBCInstructions> 0)
                   .Average(m => m.BCCyclomaticComplexity)]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Max IL Nesting Depth for Methods" Unit="Scopes" />
Application.Methods
           .Max(m => m.BCNestingDepth)

// Here is the code query to get the method with higher BCNestingDepth.
// Application.Methods.OrderByDescending(m => m.BCNestingDepth).Take(1).Select(m => new {m, m.BCNestingDepth})]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Average IL Nesting Depth for Methods" Unit="Scopes" />
Application.Methods.Where(m => m.NbBCInstructions> 0)
                   .Average(m => m.BCNestingDepth)]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Max # of Methods for Types" Unit="Methods" />
Application.Types
           .Max(t => t.NbMethods) 

// Here is the code query to get the (JustMyCode) type with largest # of Methods
// JustMyCode.Types.OrderByDescending(t => t.NbMethods).Take(1).Select(t => new {t, t.Methods})]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Average # Methods for Types" Unit="Methods" />
Application.Types.Average(t => t.NbMethods)]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Max # of Methods for Interfaces" Unit="Methods" />
Application.Types.Where(t => t.IsInterface)
                 .Max(t => t.NbMethods)

// Here is the code query to get the (JustMyCode) type with largest # of Methods
// JustMyCode.Types.OrderByDescending(t => t.NbMethods).Take(1).Select(t => new {t, t.Methods})]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Average # Methods for Interfaces" Unit="Methods" />
JustMyCode.Types.Where(t => t.IsInterface)
                .Average(t => t.NbMethods)]]></Query>
      </Group>
      <Group Name="Coverage" Active="True" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Percentage Code Coverage" Unit="%" />
codeBase.PercentageCoverage]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Lines of Code Covered" Unit="LoC" />
codeBase.NbLinesOfCodeCovered]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Lines of Code Not Covered" Unit="LoC" />
codeBase.NbLinesOfCodeNotCovered]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Lines of Code Uncoverable" Unit="LoC" />
(codeBase.NbLinesOfCode - codeBase.NbLinesOfCodeCovered - codeBase.NbLinesOfCodeNotCovered).ToNullableDouble()

//<Description>
// **Lines of Code Uncoverable** are lines of code in methods tagged with the *Uncoverable attribute*
// or methods in types or Projects tagged with the *Uncoverable attribute*.
//
// The *Uncoverable attribute* is defined in the:
//   NDepend Project Properties > Analysis > Code Coverage > Un-Coverable attributes.
//
// These methods can be listed with the code query:
//   *from m in Methods where !m.CoverageDataAvailable && m.NbLinesOfCode > 0 select new { m, m.NbLinesOfCode }*
//
// If coverage data imported at analysis time is not *in-sync* with the analyzed code base,
// this code query will also list methods not defined in the coverage data imported.
//</Description>]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Lines of Code in Types 100% Covered" Unit="LoC" />
Application.Types.Where(t => t.PercentageCoverage == 100)
                 .Sum(t => t.NbLinesOfCodeCovered)

//<Description>
// A line of code covered by tests is *even more valuable* if it is in a type 100% covered by test.
//
// Covering 90% of a class is not enough.
//
// • It means that this 10% uncovered code is hard-to-test,
//
// • which means that this code is not well-designed,
//
// • which means that it is error-prone.
//
// Better test error-prone code, isn't it?
//</Description>]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Lines of Code in Methods 100% Covered" Unit="LoC" />
Application.Methods.Where(m => m.PercentageCoverage == 100)
                   .Sum(m => m.NbLinesOfCodeCovered)

//<Description>
// The same remark than in the Trend Metric **# Lines of Code in Types 100% Covered**
// applies for method 100% covered.
//
// A line of code covered by tests is *even more valuable* if it is in a method 100% covered by test.
//</Description>]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Max C.R.A.P Score" />

(from m in JustMyCode.Methods

// Don't match too short methods
where m.NbLinesOfCode > 10

let CC = m.CyclomaticComplexity
let uncov = (100 - m.PercentageCoverage) / 100f
let CRAP = (CC * CC * uncov * uncov * uncov) + CC
where CRAP != null && CRAP > 30 select CRAP)
.Max(CRAP => CRAP)

//<Description>
// **Change Risk Analyzer and Predictor** (i.e. CRAP) is a code metric
// that helps in pinpointing overly complex and untested code.
// Is has been first defined here: 
// http://www.artima.com/weblogs/viewpost.jsp?thread=215899
//
// The Formula is:  **CRAP(m) = CC(m)^2 * (1 – cov(m)/100)^3 + CC(m)**
//
// • where *CC(m)* is the *cyclomatic complexity* of the method *m*
//
// • and *cov(m)* is the *percentage coverage* by tests of the method *m*
//
// Matched methods cumulates two highly *error prone* code smells:
//
// • A complex method, difficult to develop and maintain.
//
// • Non 100% covered code, difficult to refactor without any regression bug.
//
// The higher the CRAP score, the more painful to maintain and error prone is the method.
//
// An arbitrary threshold of 30 is fixed for this code rule as suggested by inventors.
//
// Notice that no amount of testing will keep methods with a Cyclomatic Complexity
// higher than 30, out of CRAP territory.
//
// Notice that CRAP score is not computed for too short methods
// with less than 10 lines of code.
//
// To list methods with higher C.R.A.P scores, please refer to the default rule:
//   *Test and Code Coverage* > *C.R.A.P method code metric*
//</Description>]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Average C.R.A.P Score" />

(from m in JustMyCode.Methods

// Don't match too short methods
where m.NbLinesOfCode > 10

let CC = m.CyclomaticComplexity
let uncov = (100 - m.PercentageCoverage) / 100f
let CRAP = (CC * CC * uncov * uncov * uncov) + CC
where CRAP != null && CRAP > 30 select CRAP)
.Average(CRAP => CRAP)

//<Description>
// **Change Risk Analyzer and Predictor** (i.e. CRAP) is a code metric
// that helps in pinpointing overly complex and untested code.
// Is has been first defined here: 
// http://www.artima.com/weblogs/viewpost.jsp?thread=215899
//
// The Formula is:  **CRAP(m) = CC(m)^2 * (1 – cov(m)/100)^3 + CC(m)**
//
// • where *CC(m)* is the *cyclomatic complexity* of the method *m*
//
// • and *cov(m)* is the *percentage coverage* by tests of the method *m*
//
// Matched methods cumulates two highly *error prone* code smells:
//
// • A complex method, difficult to develop and maintain.
//
// • Non 100% covered code, difficult to refactor without any regression bug.
//
// The higher the CRAP score, the more painful to maintain and error prone is the method.
//
// An arbitrary threshold of 30 is fixed for this code rule as suggested by inventors.
//
// Notice that no amount of testing will keep methods with a Cyclomatic Complexity
// higher than 30, out of CRAP territory.
//
// Notice that CRAP score is not computed for too short methods
// with less than 10 lines of code.
//
// To list methods with higher C.R.A.P scores, please refer to the default rule:
//   *Test and Code Coverage* > *C.R.A.P method code metric*
//</Description>]]></Query>
      </Group>
      <Group Name="Third-Party Usage" Active="True" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Third-Party Projects Used" Unit="Projects" />
from a in ThirdParty.Projects
select new { a, a.ProjectsUsingMe }]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Third-Party Packages Used" Unit="Packages" />
from n in ThirdParty.Packages
select new { n, n.PackagesUsingMe }]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Third-Party Types Used" Unit="Types" />
from t in ThirdParty.Types
select new { t, t.TypesUsingMe }]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Third-Party Methods Used" Unit="Methods" />
from m in ThirdParty.Methods
select new { m, m.MethodsCallingMe }]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Third-Party Fields Used" Unit="Fields" />
from f in ThirdParty.Fields
where !f.ParentType.IsEnumeration
select new { f, f.MethodsUsingMe }]]></Query>
        <Query Active="False" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Third-Party Code Elements Used" Unit="Code Elements" />
from elem in ThirdParty.CodeElements
where !(elem.IsField && elem.AsField.ParentType.IsEnumeration)
let users = elem.IsMethod ?    elem.AsMethod.MethodsCallingMe.Cast<ICodeElement>() :
            elem.IsField  ?    elem.AsField.MethodsUsingMe.Cast<ICodeElement>() :
            elem.IsType ?      elem.AsType.TypesUsingMe.Cast<ICodeElement>() :
            elem.IsPackage ? elem.AsPackage.PackagesUsingMe.Cast<ICodeElement>() :
                               elem.AsProject.ProjectsUsingMe.Cast<ICodeElement>()
select new { elem, users }
]]></Query>
      </Group>
    </Group>
    <Group Name="Hot Spots" Active="True" ShownInReport="True">
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Types Hot Spots</Name>
from t in JustMyCode.Types
where t.AllDebt() > Debt.Zero && 
      t.AllAnnualInterest() > AnnualInterest.Zero
orderby t.AllDebt().Value.TotalMinutes descending
select new { t, 
   Debt = t.AllDebt(),
   Issues = t.AllIssues(), // AllIssues = {types issues} union {members issues}
   AnnualInterest = t.AllAnnualInterest(),
   BreakingPoint = t.AllBreakingPoint(),
   t.NbLinesOfCode,
   // t.PercentageCoverage,  to uncomment if coverage data is imported
   DebtRating = t.DebtRating(), 
   DebtRatio = t.DebtRatio() 
}

//<Description>
// This query lists **types with most Debt**,
// or in other words, types with issues that would need 
// the largest effort to get fixed.
//
// Both issues on the type and its members are
// taken account.
//
// Since untested code often generates a lot of 
// Debt, the type size and percentage coverage is shown
// (just uncomment *t.PercentageCoverage* in the query 
// source code once you've imported the coverage data).
//
// The *Debt Rating* and *Debt Ratio* are also shown
// for informational purpose.
//
// --
//
// The amount of *Debt* is not a measure to prioritize
// the effort to fix issues, it is an estimation of how far 
// the team is from clean code that abides by the rules set.
//
// For each issue the *Annual Interest* estimates the annual 
// cost to leave the issues unfixed. The *Severity* of an issue
// is estimated through thresholds from the *Annual Interest*.
//
// The **Debt Breaking Point** represents the duration
// from now when the estimated cost to leave the issue unfixed
// costs as much as the estimated effort to fix it.
//
// Hence the shorter the **Debt Breaking Point** 
// the largest the **Return on Investment** for fixing 
// the issue. The **Breaking Point is the right metric
// to prioritize issues fix**.
//</Description>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Types to Fix Priority</Name>
from t in JustMyCode.Types
where t.AllBreakingPoint() > TimeSpan.Zero &&
      t.AllDebt().Value > 30.ToMinutes()
orderby t.AllBreakingPoint().TotalMinutes ascending
select new { t, 
   BreakingPoint = t.AllBreakingPoint(),
   Debt = t.AllDebt(),
   AnnualInterest = t.AllAnnualInterest(),
   Issues = t.AllIssues(),
   t.NbLinesOfCode,
   // t.PercentageCoverage,  to uncomment if coverage data is imported
   DebtRating = t.DebtRating(), 
   DebtRatio = t.DebtRatio() 
}

//<Description>
// This query lists types per increasing
// **Debt Breaking Point**.
//
// For each issue the *Debt* estimates the
// effort to fix the issue, and the *Annual Interest*
// estimates the annual cost to leave the issue unfixed.
// The *Severity* of an issue is estimated through 
// thresholds from the *Annual Interest* of the issue.
//
// The **Debt Breaking Point** represents the duration
// from now when the estimated cost to leave the issue unfixed
// costs as much as the estimated effort to fix it.
//
// Hence the shorter the **Debt Breaking Point** 
// the largest the **Return on Investment** for fixing 
// the issues.
//
// Often new and refactored types since baseline will be 
// listed first, because issues on these types get a 
// higher *Annual Interest* because it is important to
// focus first on new issues.
// 
//
// --
//
// Both issues on the type and its members are
// taken account.
//
// Only types with at least 30 minutes of Debt are listed
// to avoid parasiting the list with the numerous
// types with small *Debt*, on which the *Breaking Point*
// value makes less sense. 
//
// The *Annual Interest* estimates the cost per year
// in man-days to leave these issues unfixed.
//
// Since untested code often generates a lot of 
// Debt, the type size and percentage coverage is shown
// (just uncomment *t.PercentageCoverage* in the query 
// source code once you've imported the coverage data).
//
// The *Debt Rating* and *Debt Ratio* are also shown
// for informational purpose.
//</Description>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Issues to Fix Priority</Name>
from i in Issues
// Don't show first issues with BreakingPoint equals to zero.
orderby i.BreakingPoint != TimeSpan.Zero ? i.BreakingPoint : TimeSpan.MaxValue
select new { i, 
   Debt = i.Debt,
   AnnualInterest = i.AnnualInterest,
   BreakingPoint = i.BreakingPoint,
   CodeElement = i.CodeElement
}

//<Description>
// This query lists issues per increasing
// **Debt Breaking Point**.
//
// Double-click an issue to edit its rule and
// select the issue in the rule result. This way
// you can view all information concerning the issue.
//
// For each issue the *Debt* estimates the
// effort to fix the issue, and the *Annual Interest*
// estimates the annual cost to leave the issue unfixed.
// The *Severity* of an issue is estimated through 
// thresholds from the *Annual Interest* of the issue.
//
// The **Debt Breaking Point** represents the duration
// from now when the estimated cost to leave the issue unfixed
// costs as much as the estimated effort to fix it.
//
// Hence the shorter the **Debt Breaking Point** 
// the largest the **Return on Investment** for fixing 
// the issue.
//
// Often issues on new and refactored code elements since 
// baseline will be listed first, because such issues get a 
// higher *Annual Interest* because it is important to
// focus first on new issues on recent code.
//</Description>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Debt and Issues per Rule</Name>
from r in Rules
where r.IsViolated()
orderby r.Debt().Value descending
select new { 
   r, 
   Issues = r.Issues(), 
   Debt = r.Debt(), 
   AnnualInterest = r.AnnualInterest(), 
   BreakingPoint = r.BreakingPoint(),
   Category = r.Category
}

//<Description>
// This query lists violated rules with most *Debt* first.
//
// A rule violated has issues. For each issue the *Debt* 
// estimates the effort to fix the issue.
//
// --
//
// The amount of *Debt* is not a measure to prioritize
// the effort to fix issues, it is an estimation of how far 
// the team is from clean code that abides by the rules set.
//
// For each issue the *Annual Interest* estimates the annual 
// cost to leave the issues unfixed. The *Severity* of an issue
// is estimated through thresholds from the *Annual Interest*.
//
// The **Debt Breaking Point** represents the duration
// from now when the estimated cost to leave the issue unfixed
// costs as much as the estimated effort to fix it.
//
// Hence the shorter the **Debt Breaking Point** 
// the largest the **Return on Investment** for fixing 
// the issue. The **Breaking Point is the right metric
// to prioritize issues fix**.
//
// --
//
// Notice that rules can be grouped in *Rule Category*. This
// way you'll see categories that generate most *Debt*.
//
// Typically the rules that generate most *Debt* are the 
// ones related to *Code Coverage by Tests*, *Architecture*
// and *Code Quality*.
//</Description>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>New Debt and Issues per Rule</Name>
from r in Rules
where r.IsViolated() && r.IssuesAdded().Count() > 0
orderby r.DebtDiff().Value descending
select new { 
   r, 
   IssuesAdded = r.IssuesAdded(),
   IssuesFixed = r.IssuesFixed(),
   Issues = r.Issues(), 
   Debt = r.Debt(), 
   DebtDiff = r.DebtDiff(),
   Category = r.Category
}

//<Description>
// This query lists violated rules that have new issues
// since baseline, with most **new Debt** first.
//
// A rule violated has issues. For each issue the *Debt* 
// estimates the effort to fix the issue.
//
// --
//
// New issues since the baseline are consequence of recent code 
// refactoring sessions. They represent good opportunities
// of fix because the code recently refactored is fresh in 
// the developers mind, which means fixing now costs less
// than fixing later.
//
// Fixing issues on recently touched code is also a good way 
// to foster practices that will lead to higher code quality 
// and maintainability, including writing unit-tests
// and avoiding unnecessary complex code.
//
// --
//
// Notice that rules can be grouped in *Rule Category*. This
// way you'll see categories that generate most *Debt*.
//
// Typically the rules that generate most *Debt* are the 
// ones related to *Code Coverage by Tests*, *Architecture*
// and *Code Quality*.
//</Description>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Debt and Issues per Code Element</Name>
from elem in CodeElements
where elem.HasIssue()
orderby elem.Debt().Value descending
select new { 
   elem, 
   Issues = elem.Issues(), 
   Debt = elem.Debt(), 
   AnnualInterest = elem.AnnualInterest(), 
   BreakingPoint = elem.BreakingPoint()
}

//<Description>
// This query lists code elements that have issues, 
// with most *Debt* first.
//
// For each code element the *Debt* estimates 
// the effort to fix the element issues.
//
// The amount of *Debt* is not a measure to prioritize
// the effort to fix issues, it is an estimation of how far 
// the team is from clean code that abides by the rules set.
//
// For each element the *Annual Interest* estimates the annual 
// cost to leave the elements issues unfixed. The *Severity* of an 
// issue is estimated through thresholds from the *Annual Interest*
// of the issue.
//
// The **Debt Breaking Point** represents the duration
// from now when the estimated cost to leave the issues unfixed
// costs as much as the estimated effort to fix it.
//
// Hence the shorter the **Debt Breaking Point** 
// the largest the **Return on Investment** for fixing 
// the issue. The **Breaking Point is the right metric
// to prioritize issues fix**.
//</Description>
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>New Debt and Issues per Code Element</Name>
from elem in CodeElements
where elem.HasIssue() && elem.IssuesAdded().Count() > 0
orderby elem.DebtDiff().Value descending
select new { 
   elem, 
   IssuesAdded = elem.IssuesAdded(),
   IssuesFixed = elem.IssuesFixed(),
   Issues = elem.Issues(), 
   Debt = elem.Debt(), 
   DebtDiff = elem.DebtDiff()
}
    //<Description>
// This query lists code elements that have new issues
// since baseline, with most **new Debt** first.
//
// For each code element the *Debt* estimates 
// the effort to fix the element issues.
//
// New issues since the baseline are consequence of recent code 
// refactoring sessions. They represent good opportunities
// of fix because the code recently refactored is fresh in 
// the developers mind, which means fixing now costs less
// than fixing later.
//
// Fixing issues on recently touched code is also a good way 
// to foster practices that will lead to higher code quality 
// and maintainability, including writing unit-tests
// and avoiding unnecessary complex code.
//</Description>
]]></Query>
    </Group>
    <Group Name="Code Diff Summary" Active="True" ShownInReport="True">
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>New Projects</Name>
from a in Application.Projects where a.WasAdded()
select new { a, a.NbLinesOfCode }

//<Description>
// This query is executed only if a *baseline for comparison* is defined (*diff mode*).
//
// This code query lists *Projects* that have been added since the *baseline*.
//</Description>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Projects removed</Name>
from a in codeBase.OlderVersion().Application.Projects where a.WasRemoved()
select new { a, a.NbLinesOfCode }

//<Description>
// This query is executed only if a *baseline for comparison* is defined (*diff mode*).
//
// This code query lists *Projects* that have been removed since the *baseline*.
//</Description>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Projects where code was changed</Name>
from a in Application.Projects where a.CodeWasChanged()
select new { 
   a, 
   a.NbLinesOfCode, 
   oldNbLinesOfCode = a.OlderVersion().NbLinesOfCode.GetValueOrDefault() ,
   delta = (int) a.NbLinesOfCode.GetValueOrDefault() - a.OlderVersion().NbLinesOfCode.GetValueOrDefault() 
}

//<Description>
// This query is executed only if a *baseline for comparison* is defined (*diff mode*).
//
// This code query lists *Projects* in which, code has been changed since the *baseline*.
//</Description>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>New packages</Name>
from n in Application.Packages where 
 !n.ParentProject.WasAdded() &&
  n.WasAdded()
select new { n, n.NbLinesOfCode }

//<Description>
// This query is executed only if a *baseline for comparison* is defined (*diff mode*).
//
// This code query lists *packages* that have been added since the *baseline*.
//</Description>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Packages removed</Name>
from n in codeBase.OlderVersion().Application.Packages where 
 !n.ParentProject.WasRemoved() &&
  n.WasRemoved()
select new { n, n.NbLinesOfCode }

//<Description>
// This query is executed only if a *baseline for comparison* is defined (*diff mode*).
//
// This code query lists *packages* that have been removed since the *baseline*.
//</Description>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Packages where code was changed</Name>
from n in Application.Packages where n.CodeWasChanged()
select new { 
   n, 
   n.NbLinesOfCode, 
   oldNbLinesOfCode = n.OlderVersion().NbLinesOfCode.GetValueOrDefault() ,
   delta = (int) n.NbLinesOfCode.GetValueOrDefault() - n.OlderVersion().NbLinesOfCode.GetValueOrDefault() 
}

//<Description>
// This query is executed only if a *baseline for comparison* is defined (*diff mode*).
//
// This code query lists *packages* in which, code has been changed since the *baseline*.
//</Description>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>New types</Name>
from t in Application.Types where 
 !t.ParentPackage.WasAdded() &&
  t.WasAdded() &&
 !t.IsGeneratedByCompiler
select new { t, t.NbLinesOfCode }

//<Description>
// This query is executed only if a *baseline for comparison* is defined (*diff mode*).
//
// This code query lists *types* that have been added since the *baseline*.
//</Description>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Types removed</Name>
from t in codeBase.OlderVersion().Application.Types where 
 !t.ParentPackage.WasRemoved() &&
  t.WasRemoved() &&
 !t.IsGeneratedByCompiler
select new { t, t.NbLinesOfCode }

//<Description>
// This query is executed only if a *baseline for comparison* is defined (*diff mode*).
//
// This code query lists *types* that have been removed since the *baseline*.
//</Description>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Types where code was changed</Name>

from t in Application.Types where t.CodeWasChanged() 
//select new { t, t.NbLinesOfCode }
select new { 
   t, 
   t.NbLinesOfCode, 
   oldNbLinesOfCode = t.OlderVersion().NbLinesOfCode ,
   delta = (int?) t.NbLinesOfCode - t.OlderVersion().NbLinesOfCode 
} 
//<Description>
// This query is executed only if a *baseline for comparison* is defined (*diff mode*).
//
// This code query lists *types* in which, code has been changed since the *baseline*.
//
// To visualize changes in code, right-click a matched type and select:
//
// • Compare older and newer versions of source file
//
// • Compare older and newer versions disassembled with Reflector
//</Description>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Heuristic to find types moved from one package or project to another</Name>
let typesRemoved = codeBase.OlderVersion().Types.Where(t => t.WasRemoved())
let typesAdded = Types.Where(t => t.WasAdded())

from tMoved in typesAdded.Join(
   typesRemoved,
   t => t.Name,
   t => t.Name,
   (tNewer, tOlder) => new { tNewer, 
                             OlderParentPackage = tOlder.ParentPackage,
                             OlderParentProject = tOlder.ParentProject  } ) 
select tMoved

//<Description>
// This query is executed only if a *baseline for comparison* is defined (*diff mode*).
//
// This code query lists *types* moved from one package or project to another.
// The heuristic implemented consists in making a **join LINQ query** on
// type name (without package prefix), applied to the two sets of types *added* 
// and types *removed*.
//</Description>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Types directly using one or several types changed</Name>
let typesChanged = Application.Types.Where(t => t.CodeWasChanged()).ToHashSetEx()

from t in JustMyCode.Types.UsingAny(typesChanged) where
  !t.CodeWasChanged() && 
  !t.WasAdded()
let typesChangedUsed = t.TypesUsed.Intersect(typesChanged) 
select new { t, typesChangedUsed }

//<Description>
// This query is executed only if a *baseline for comparison* is defined (*diff mode*).
//
// This code query lists types *unchanged* since the *baseline*
// but that use directly some *types* where code has been changed 
// since the *baseline*.
//
// For such matched type, the code hasen't been changed, but still the overall
// behavior might have been changed.
//
// The query result includes types changed directly used,
//</Description>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Types indirectly using one or several types changed</Name>
let typesChanged = Application.Types.Where(t => t.CodeWasChanged()).ToHashSetEx()

// 'depth' represents a code metric defined on types using
// directly or indirectly any type where code was changed.
let depth = JustMyCode.Types.DepthOfIsUsingAny(typesChanged) 

from t in depth.DefinitionDomain where
  !t.CodeWasChanged() && 
  !t.WasAdded()

let typesChangedDirectlyUsed = t.TypesUsed.Intersect(typesChanged) 
let depthOfUsingTypesChanged = depth[t]
orderby depthOfUsingTypesChanged 

select new { 
   t, 
   depthOfUsingTypesChanged, 
   typesChangedDirectlyUsed 
}

//<Description>
// This query is executed only if a *baseline for comparison* is defined (*diff mode*).
//
// This code query lists types *unchanged* since the *baseline*
// but that **use directly or indirectly** some *types* where 
// code has been changed since the *baseline*.
//
// For such matched type, the code hasen't been changed, but still the overall
// behavior might have been changed.
// 
// The query result includes types changed directly used, and the **depth of usage**
// of types indirectly used, *depth of usage* as defined in the documentation of
// *DepthOfIsUsingAny()* NDepend API method:
// http://www.jarchitect.com/api/webframe.html?NDepend.API~NDepend.CodeModel.ExtensionMethodsSequenceUsage~DepthOfIsUsingAny.html
//</Description>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>New methods</Name>
from m in Application.Methods where 
 !m.ParentType.WasAdded() &&
  m.WasAdded() &&
 !m.IsGeneratedByCompiler
select new { m, m.NbLinesOfCode }

//<Description>
// This query is executed only if a *baseline for comparison* is defined (*diff mode*).
//
// This code query lists *methods* that have been added since the *baseline*.
//</Description>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Methods removed</Name>
from m in codeBase.OlderVersion().Application.Methods where 
 !m.ParentType.WasRemoved() &&
  m.WasRemoved() &&
 !m.IsGeneratedByCompiler
select new { m, m.NbLinesOfCode }

//<Description>
// This query is executed only if a *baseline for comparison* is defined (*diff mode*).
//
// This code query lists *methods* that have been removed since the *baseline*.
//</Description>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Methods where code was changed</Name>
from m in Application.Methods where m.CodeWasChanged()
select new { 
   m, 
   m.NbLinesOfCode, 
   oldNbLinesOfCode = m.OlderVersion().NbLinesOfCode ,
   delta = (int?) m.NbLinesOfCode - m.OlderVersion().NbLinesOfCode 
}

//<Description>
// This query is executed only if a *baseline for comparison* is defined (*diff mode*).
//
// This code query lists *methods* in which, code has been changed since the *baseline*.
//
// To visualize changes in code, right-click a matched method and select:
//
// • Compare older and newer versions of source file
//
// • Compare older and newer versions disassembled with Reflector
//</Description>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Methods directly calling one or several methods changed</Name>
let methodsChanged = Application.Methods.Where(m => m.CodeWasChanged()).ToHashSetEx()

from m in JustMyCode.Methods.UsingAny(methodsChanged ) where
  !m.CodeWasChanged() && 
  !m.WasAdded()
let methodsChangedCalled = m.MethodsCalled.Intersect(methodsChanged) 
select new { 
   m, 
   methodsChangedCalled 
}

//<Description>
// This query is executed only if a *baseline for comparison* is defined (*diff mode*).
//
// This code query lists methods *unchanged* since the *baseline*
// but that call directly some *methods* where code has been changed 
// since the *baseline*.
//
// For such matched method, the code hasen't been changed, but still the overall
// behavior might have been changed.
//
// The query result includes methods changed directly used,
//</Description>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Methods indirectly calling one or several methods changed</Name>
let methodsChanged = Application.Methods.Where(m => m.CodeWasChanged()).ToHashSetEx()

// 'depth' represents a code metric defined on methods using
// directly or indirectly any method where code was changed.
let depth = JustMyCode.Methods.DepthOfIsUsingAny(methodsChanged) 

from m in depth.DefinitionDomain where
  !m.CodeWasChanged() && 
  !m.WasAdded()

let methodsChangedDirectlyUsed = m.MethodsCalled.Intersect(methodsChanged) 
let depthOfUsingMethodsChanged = depth[m]
orderby depthOfUsingMethodsChanged 

select new { 
   m, 
   depthOfUsingMethodsChanged, 
   methodsChangedDirectlyUsed 
}

//<Description>
// This query is executed only if a *baseline for comparison* is defined (*diff mode*).
//
// This code query lists methods *unchanged* since the *baseline*
// but that **use directly or indirectly** some *methods* where 
// code has been changed since the *baseline*.
//
// For such matched method, the code hasen't been changed, but still the overall
// behavior might have been changed.
// 
// The query result includes methods changed directly used, and the **depth of usage**
// of methods indirectly used, *depth of usage* as defined in the documentation of
// *DepthOfIsUsingAny()* NDepend API method:
// http://www.jarchitect.com/api/webframe.html?NDepend.API~NDepend.CodeModel.ExtensionMethodsSequenceUsage~DepthOfIsUsingAny.html
//</Description>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>New fields</Name>
from f in Application.Fields where 
 !f.ParentType.WasAdded() &&
  f.WasAdded() &&
 !f.IsGeneratedByCompiler
select f

//<Description>
// This query is executed only if a *baseline for comparison* is defined (*diff mode*).
//
// This code query lists *fields* that have been added since the *baseline*.
//</Description>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Fields removed</Name>
from f in codeBase.OlderVersion().Application.Fields where 
 !f.ParentType.WasRemoved() &&
  f.WasRemoved() &&
 !f.IsGeneratedByCompiler
select f

//<Description>
// This query is executed only if a *baseline for comparison* is defined (*diff mode*).
//
// This code query lists *fields* that have been removed since the *baseline*.
//</Description>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Third party types that were not used and that are now used</Name>
from t in ThirdParty.Types where t.IsUsedRecently()
select new { 
   t, 
   t.Methods, 
   t.Fields, 
   t.TypesUsingMe 
}

//<Description>
// This query is executed only if a *baseline for comparison* is defined (*diff mode*).
//
// This code query lists *types* defined in **third-party Projects**, that were not 
// used at *baseline* time, and that are now used.
//</Description>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Third party types that were used and that are not used anymore</Name>
from t in codeBase.OlderVersion().Types where t.IsNotUsedAnymore()
select new { 
   t, 
   t.Methods, 
   t.Fields, 
   TypesThatUsedMe = t.TypesUsingMe 
}

//<Description>
// This query is executed only if a *baseline for comparison* is defined (*diff mode*).
//
// This code query lists *types* defined in **third-party Projects**, that were  
// used at *baseline* time, and that are not used anymore.
//</Description>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Third party methods that were not used and that are now used</Name>
from m in ThirdParty.Methods where 
  m.IsUsedRecently() &&
 !m.ParentType.IsUsedRecently()
select new { 
   m, 
   m.MethodsCallingMe
}

//<Description>
// This query is executed only if a *baseline for comparison* is defined (*diff mode*).
//
// This code query lists *methods* defined in **third-party Projects**, that were not 
// used at *baseline* time, and that are now used.
//</Description>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Third party methods that were used and that are not used anymore</Name>
from m in codeBase.OlderVersion().Methods where 
  m.IsNotUsedAnymore() &&
 !m.ParentType.IsNotUsedAnymore()
select new { 
   m, 
   MethodsThatCalledMe = m.MethodsCallingMe
}

//<Description>
// This query is executed only if a *baseline for comparison* is defined (*diff mode*).
//
// This code query lists *methods* defined in **third-party Projects**, that were  
// used at *baseline* time, and that are not used anymore.
//</Description>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Third party fields that were not used and that are now used</Name>
from f in ThirdParty.Fields where 
  f.IsUsedRecently() &&
 !f.ParentType.IsUsedRecently()
select new { 
   f, 
   f.MethodsUsingMe 
}

//<Description>
// This query is executed only if a *baseline for comparison* is defined (*diff mode*).
//
// This code query lists *fields* defined in **third-party Projects**, that were not 
// used at *baseline* time, and that are now used.
//</Description>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Third party fields that were used and that are not used anymore</Name>
from f in codeBase.OlderVersion().Fields where 
  f.IsNotUsedAnymore() &&
 !f.ParentType.IsNotUsedAnymore()
select new {
   f, 
   MethodsThatUsedMe = f.MethodsUsingMe
}

//<Description>
// This query is executed only if a *baseline for comparison* is defined (*diff mode*).
//
// This code query lists *fields* defined in **third-party Projects**, that were  
// used at *baseline* time, and that are not used anymore.
//</Description>]]></Query>
    </Group>
    <Group Name="Defining JustMyCode" Active="True" ShownInReport="False">
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Discard methods in a directory  from JustMyCode</Name>
notmycode from m in Methods.Where(a=>a.SourceDecls.FirstOrDefault()!=null && a.SourceDecls.FirstOrDefault().SourceFile.DirectoryPath.Contains("path to exclude"))
select m

]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Discard types in a directory  from JustMyCode</Name>
notmycode from t in Types.Where(a=>a.SourceDecls.FirstOrDefault()!=null && a.SourceDecls.FirstOrDefault().SourceFile.DirectoryPath.Contains("path to exclude"))
select t

]]></Query>
    </Group>
    <Group Name="Statistics" Active="False" ShownInReport="False">
      <Query Active="True" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Most used types (Rank)</Name>
(from t in Application.Types orderby t.Rank descending
 select new { t, t.Rank }).Take(50)

// TypeRank values are computed by applying 
// the Google PageRank  algorithm on the 
// graph of types' dependencies. Types with 
// high Rank are the most used ones.
// See the definition of the TypeRank metric here: 
// http://www.jarchitect.com/Metrics.aspx#TypeRank]]></Query>
      <Query Active="True" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Most used methods (Rank)</Name>
(from m in Application.Methods orderby m.Rank descending
 select new { m, m.Rank }).Take(50)

// MethodRank values are computed by applying 
// the Google PageRank  algorithm on the graph of 
// methods' dependencies. Methods with high Rank 
// are the most used ones. See the definition of 
// the MethodRank metric here:
// http://www.jarchitect.com/Metrics.aspx#MethodRank]]></Query>
      <Query Active="True" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Most used packages (#PackagesUsingMe )</Name>
(from n in Packages orderby n.NbPackagesUsingMe descending
 select new { n, n.PackagesUsingMe }).Take(50)]]></Query>
      <Query Active="True" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Most used types (#TypesUsingMe )</Name>
(from t in Types orderby t.NbTypesUsingMe descending
 select new { t, t.TypesUsingMe }).Take(50)]]></Query>
      <Query Active="True" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Most used methods (#MethodsCallingMe )</Name>
(from m in Methods orderby m.NbMethodsCallingMe descending
 select new { m, m.MethodsCallingMe }).Take(50)]]></Query>
      <Query Active="True" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Packages that use many other packages (#PackagesUsed )</Name>
(from n in Application.Packages orderby n.NbPackagesUsed descending
 select new { n, n.PackagesUsed }).Take(50)]]></Query>
      <Query Active="True" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Types that use many other types (#TypesUsed )</Name>
(from t in Application.Types orderby t.NbTypesUsed descending
 select new { t, t.TypesUsed }).Take(50)]]></Query>
      <Query Active="True" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Methods that use many other methods (#MethodsCalled )</Name>
(from m in Application.Methods orderby m.NbMethodsCalled descending
 select new { m, m.MethodsCalled }).Take(50)]]></Query>
      <Query Active="True" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>High-level to low-level projects (Level)</Name>
from a in Application.Projects orderby a.Level descending
select new { a, a.Level }

// Classify projects by their Level values.
// See the definition of the ProjectLevel metric here:
// http://www.jarchitect.com/Metrics.aspx#Level]]></Query>
      <Query Active="True" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>High-level to low-level packages (Level)</Name>
from n in Application.Packages orderby n.Level descending
select new { n, n.Level }

// Classify packages by their Level values.
// See the definition of the PackageLevel metric here:
// http://www.jarchitect.com/Metrics.aspx#Level]]></Query>
      <Query Active="True" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>High-level to low-level types (Level)</Name>
from t in Application.Types orderby t.Level descending
select new { t, t.Level }

// Classify types by their Level values.
// See the definition of the TypeLevel metric here:
// http://www.jarchitect.com/Metrics.aspx#Level]]></Query>
      <Query Active="True" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>High-level to low-level methods (Level)</Name>
from m in Application.Methods orderby m.Level descending
select new { m, m.Level }

// Classify methods by their Level values.
// See the definition of the MethodLevel metric here:
// http://www.jarchitect.com/Metrics.aspx#Level]]></Query>
    </Group>
    <Group Name="Samples of Custom rules" Active="False" ShownInReport="False">
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Check that the project Prj1 is not using the project Prj2</Name>
warnif count > 0 from a in Application.Projects where 
  a.IsUsing ("Prj2".AllowNoMatch().MatchProject()) &&
  (a.Name == @"Prj1")
select a
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Check that the package N1.N2 is not using the package N3.N4.N5</Name>
warnif count > 0 from n in Application.Packages where 
  n.IsUsing ("N3.N4.N5".AllowNoMatch().MatchProject()) &&
  (n.Name == @"N1.N2")
select n
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Check that the project Prj1 is only using the projects Prj2, Prj3</Name>
warnif count > 0 from a in Application.Projects where 
  ( !a.IsUsing ("Prj2".AllowNoMatch().MatchProject()) ||
    !a.IsUsing ("Prj3".AllowNoMatch().MatchProject()) ||
     a.ProjectsUsed.Count() != 3) // Must not be used more than 3 projects 
&& 
  (a.Name == @"Prj1")
select new { a, a.ProjectsUsed }
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Check that all methods that call Foo.Fct1() also call Foo.Fct2(Int32)</Name>
warnif count > 0 from m in Application.Methods where 
   m.IsUsing ("Foo.Fct1()".AllowNoMatch()) &&
  !m.IsUsing ("Foo.Fct2(Int32)".AllowNoMatch())
select m
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Check that all types that derive from Foo, also implement IFoo</Name>
warnif count > 0 from t in Application.Types where 
   t.DeriveFrom ("Foo".AllowNoMatch().MatchType()) &&
  !t.Implement ("IFoo".AllowNoMatch().MatchType())
select t
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Check that all types that has the attribute FooAttribute are declared in the package N1.N2*</Name>
warnif count > 0 from t in 
  Application.Packages.WithNameWildcardMatchNotIn("N1.N2*").ChildTypes() 
  where 
    t.HasAnnotation ("FooAttribute".AllowNoMatch())
select t]]></Query>
      <Group Name="Check Coverage on particular Code Elements" Active="False" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Check that the project Asm is 100% covered by tests</Name>
warnif count > 0 from a in Application.Projects where 
  (a.Name == @"Asm") && 
   a.PercentageCoverage < 100
select new { a, a.PercentageCoverage }


// To run this rule properly coverage data 
// must be gathered from Cobertura
// This can be done throught the menu: 
//   JArchitect -> Coverage -> Import Coverage Files
// This can be done at analysis time throught the menu: 
// Project Properties -> Analysis -> Code Coverage
// More information on how to import coverage data here:
// http://www.jarchitect.com/Coverage.aspx

]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Check that the package N1.N2 is 100% covered by tests</Name>
warnif count > 0 from n in Application.Packages where 
  (n.Name == @"N1.N2") && 
   n.PercentageCoverage < 100
select new { n, n.PercentageCoverage }


// To run this rule properly coverage data 
// must be gathered from Cobertura
// This can be done throught the menu: 
//   JArchitect -> Coverage -> Import Coverage Files
// This can be done at analysis time throught the menu: 
// Project Properties -> Analysis -> Code Coverage
// More information on how to import coverage data here:
// http://www.jarchitect.com/Coverage.aspx

]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Check that the class package.Foo is 100% covered by tests</Name>
warnif count > 0 from t in Application.Types where 
  (t.FullName == @"package.Foo") && 
   t.PercentageCoverage < 100
select new { t, t.PercentageCoverage }


// To run this rule properly coverage data 
// must be gathered from Cobertura
// This can be done throught the menu: 
//   JArchitect -> Coverage -> Import Coverage Files
// This can be done at analysis time throught the menu: 
// Project Properties -> Analysis -> Code Coverage
// More information on how to import coverage data here:
// http://www.jarchitect.com/Coverage.aspx

]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Check that the class package.Foo.Method(Int32) is 100% covered by tests</Name>
warnif count > 0 from t in Application.Types where 
  (t.FullName == @"package.Foo.Method(Int32)") && 
   t.PercentageCoverage < 100
select new { t, t.PercentageCoverage }


// To run this rule properly coverage data 
// must be gathered from Cobertura
// This can be done throught the menu: 
//   JArchitect -> Coverage -> Import Coverage Files
// This can be done at analysis time throught the menu: 
// Project Properties -> Analysis -> Code Coverage
// More information on how to import coverage data here:
// http://www.jarchitect.com/Coverage.aspx

]]></Query>
      </Group>
      <Group Name="Custom Naming Conventions" Active="False" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Check that all types that derive from Foo, has a name that ends up with Foo</Name>
warnif count > 0 from t in Application.Types where 
   t.DeriveFrom ("Foo".AllowNoMatch().MatchType()) &&
  !t.NameLike (@"Foo$")
select new { t, t.NbLinesOfCode }
]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Check that all packages begins with CompanyName.ProductName</Name>
warnif count > 0 from n in Application.Packages where 
  !n.NameLike (@"^CompanyName.ProductName")
select new { n, n.NbLinesOfCode } ]]></Query>
      </Group>
    </Group>
  </Queries></NDepend>